[{"content":" 最近测试环境上的JAR包和配置文件被误删除了，导致系统不能正常访问。由于是在内网环境，导致删除恢复软件不能被正常安装，因此只能临时恢复正在执行的JAR包，保证系统能正常访问。\n操作步骤 环境准备 启用jar应用 1 java -jar client-1.0-SNAPSHOT.jar 删除jar包 1 rm -rf client-1.0-SNAPSHOT.jar 恢复文件 查询进程号 1 ps aux|grep java|grep client 进入进程目录 1 2 3 4 5 # cd /proc/进程号/fd cd /proc/84885/fd # 查看文件信息 ls -l 恢复执行文件 1 2 3 4 5 6 # 5是删除文件的映射文件 cat 5 \u0026gt; /root/demo/client-1.0-SNAPSHOT.jar # 查看恢复结果 cd /root/demo ls -lh 查看结果 Sheel脚本（批量恢复） 由于环境涉及的应用较多，我编写了恢复shell脚本，可以恢复整个目录中的执行文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 for pid in $(ps aux | grep java | awk \u0026#39;{ print $2 }\u0026#39;); do echo \u0026#34;Try to recover the files of $pid\u0026#34; for file in $(ls -l /proc/$pid/fd | awk \u0026#39;{print $9}\u0026#39;); do symlink_dir=$(ls -l /proc/$pid/fd/$file | awk \u0026#39;{print $11}\u0026#39;) # 判断是否满足恢复的条件 if [[ $symlink_dir =~ ^/data/soft/.*$ ]]; then if [ ! -d \u0026#34;$(dirname symlink_dir)\u0026#34; ]; then mkdir -p \u0026#34;$(dirname symlink_dir)\u0026#34; fi if [ ! -f \u0026#34;$symlink_dir\u0026#34; ]; then cat \u0026#34;/proc/$pid/fd/$file\u0026#34; \u0026gt; \u0026#34;$symlink_dir\u0026#34; echo \u0026#34;Copied $file to $symlink_dir\u0026#34; else echo \u0026#34;$file already exists in $symlink_dir. Skipping...\u0026#34; fi fi done done ","date":"2024-04-17T08:47:29+08:00","image":"https://c-poet.github.io/post/linux/linux-recovery-running-file/ls-process-dir_hu8289273e5865ee1a9c9c217e668bb68d_153946_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/linux/linux-recovery-running-file/","title":"Linux恢复正在运行进程的执行文件"},{"content":"说明 Idea更新至新版本（2023.1）后， 在Linux环境下默认会开启JMX监控并输出日志。\n关闭JMX监控 打开Configurations配置面板。 打开Modify options(ALt + M)选项面板。 勾选Disable JMX endpoints。 修改Configurations模板 确定不需要打印JMX日志的情况下，可以通过修改Configuration模板一劳永逸。\n打开Configurations配置面板。 点击Edit Configutains Tempalte打开编辑模板面板。 左侧列表中找到Spring Boot模板。 打开Modify options(ALt + M)选项面板。 勾选Disable JMX endpoints。 ","date":"2024-04-13T15:19:13+08:00","image":"https://c-poet.github.io/post/mixeds/linux-idea-disable-stack-log/screenshot-log_hufc3a932f397b20b437bfa56c723d0d00_420098_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/mixeds/linux-idea-disable-stack-log/","title":"Linux Idea启动项目打印堆栈日志（JMX监控日志）"},{"content":" Spring-Security在默认情况下是不允许客户端进行缓存的，在使用时可以通过禁用Spring-Security中的cacheControl配置项允许缓存。\n1 2 3 4 protected void configure(HttpSecurity http) throws Exception { // 允许缓存配置 http.headers().cacheControl().disable(); } ","date":"2024-04-13T15:09:54+08:00","permalink":"https://c-poet.github.io/post/framework/spring/spring-security-using-browser-cache/","title":"使用Spring-Security后，浏览器不能缓存的问题"},{"content":" 在上小学期的时间里，用C语言简单的写了一个银行的管理系统实例，整体上还是显得有些粗糙。但是对于初学者来说，可以作为一些参考。程序的编写环境是VS2013，为了能让学校运行，所以在DEVC++中进行了测试。由于在编写的时候在循环体中加入了局部变量，所以在VC++中是不能被编译的，如果有需要的同学可以自行修改。\n应用代码 1. 全局头文件(banksystem.h) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* **banksystem文件头 **ASorb time:201807 */ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;time.h\u0026gt; //基本常量 #define user_max 99\t//用户最大数 #define take_notes_max 20\t//记录数 #define data_file \u0026#34;bankdata.orb\u0026#34;\t//数据文件默认地址 #define user_size sizeof(user) //结构体变量 struct take_notes{ char handle[10];\t//操作 float money;\t//操作的钱数 struct tm T;\t//时间结构体 }; typedef struct{ char name[25];\t//用户名 unsigned int card;\t//银行卡号 char pass[8];\t//密码 float balance;\t//余额 struct take_notes list[take_notes_max]; }user; //宏 2. 入口文件（main.cpp） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* **功能实现：银行系统实例 **开发环境：VS2013 **ASorb time:201807 **默认管理名：asorb 号：18072801 密码：123456 **测试环境：DEVC++5.10 （修改：1/结构体不能直接赋值，分成员赋值） */ //主函数 #include\u0026#34;banksystem.h\u0026#34; int main(){ void file_true(); void face(); char face_1(); void face_2(); void add_user(); user* login(); face();\t//初始化窗口 file_true(); char h1; while ((h1 = face_1()) != \u0026#39;Q\u0026#39;) { if (h1 == \u0026#39;A\u0026#39;){ if (login()-\u0026gt;name[0] != NULL){ system(\u0026#34;cls\u0026#34;); face_2(); } } else if (h1 == \u0026#39;B\u0026#39;) add_user(); } return 0; } 3. 功能函数文件（function.cpp） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 /* **功能函数 **ASorb time:201807 */ #include\u0026#34;banksystem.h\u0026#34; //添加新用户 void add_user(){ int user_num(); void file_read(user*); void file_save(user*, int); user p = { NULL }; char y = NULL; printf(\u0026#34;\\n\\n注册用户\\n\u0026#34;); printf(\u0026#34;--------------\\n你的姓名（20字符内）：\u0026#34;); fflush(stdin); gets(p.name); printf(\u0026#34;你的密码（6个字符）：\u0026#34;); fflush(stdin); gets(p.pass); if (strlen(p.name) == 0 || strlen(p.name) \u0026gt; 20){ printf(\u0026#34;ERROR224：姓名格式错误！\\n\u0026#34;); y = \u0026#39;N\u0026#39;; } if (strlen(p.pass) != 6){ printf(\u0026#34;ERROR224：密码格式错误！\\n\u0026#34;); y = \u0026#39;N\u0026#39;; } if (y == NULL){ user list[user_max] = { NULL }; file_read(list); for (int i = user_num() - 1; i \u0026gt;= 0; i--) if (strcmp(list[i].name, p.name) == 0){ printf(\u0026#34;------------------\\n\u0026#34;); printf(\u0026#34;提示：系统检测到存在相同的用户名，继续注册将添加新的卡号！\\n\u0026#34;); printf(\u0026#34;\\tY.继续\\t回车键放弃\\n\u0026#34;); printf(\u0026#34;键入选择：\u0026#34;); fflush(stdin); y = getchar(); } if (y == \u0026#39;Y\u0026#39; || y == NULL){ (p.card) = ((list + (user_num() - 1))-\u0026gt;card + 1);\t//新银行卡号 p.balance = 0; list[user_num()] = p;\t//加入用户 file_save(list, user_num() + 1); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：注册成功！\\n\\t用户名：%s\\t卡号:%d\u0026#34;, p.name, p.card); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：用户放弃注册！\u0026#34;); } } else{ printf(\u0026#34;\\n提示：注册失败！回车键返回...\\n\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } } //用户登录 user* login(){ static user p = { NULL }; int user_num(); void file_read(user*); user list[user_max] = { NULL }; file_read(list); if (p.name[0] == NULL){ printf(\u0026#34;--------------------\\n\u0026#34;); printf(\u0026#34;输入卡号：\u0026#34;); fflush(stdin); scanf(\u0026#34;%d\u0026#34;, \u0026amp;p.card); printf(\u0026#34;输入密码：\u0026#34;); fflush(stdin); gets(p.pass); for (int i = user_num() - 1; i \u0026gt;= 0; i--){ if (list[i].card == p.card){ if (strcmp(list[i].pass, p.pass) == 0) p = list[i]; else{ p.name[0] = NULL; printf(\u0026#34;提示：密码错误！回车键返回.....\\n\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } break; } else if (i == 0){ p.name[0] = NULL; printf(\u0026#34;提示：卡号不存在！回车键返回......\\n\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } } } else{ for (int i = user_num(); i \u0026gt;= 0; i--) if (list[i].card == p.card){ p = list[i]; break; } } return \u0026amp;p; } //余额查询 void balance_num(){ user* login(); user *p = login(); void handle_save(struct tm*,float,char arr[]); struct tm* time_now(); static int num_1 = 1; struct tm *t = time_now(); printf(\u0026#34;余额查询-银行系统实例\\n\\n\\n\\n\u0026#34;); printf(\u0026#34;\\t┌────────────────┬────────────────┬──────────────────┐\\n\u0026#34;); printf(\u0026#34;\\t│姓名：%-10s│卡号：%-10d│余额：%10.2f元│\\n\u0026#34;, p-\u0026gt;name, p-\u0026gt;card, p-\u0026gt;balance); printf(\u0026#34;\\t└────────────────┴────────────────┴──────────────────┘\\n\u0026#34;); handle_save(t, 0,\u0026#34;balance\u0026#34;);\t//保存记录 printf(\u0026#34;\\n\\t$$当前时间：%d-%d-%d %d:%d:%d 已记录\u0026#34;, 1900+t-\u0026gt;tm_year, 1+t-\u0026gt;tm_mon,t-\u0026gt;tm_mday,8+t-\u0026gt;tm_hour,t-\u0026gt;tm_min,t-\u0026gt;tm_sec); printf(\u0026#34;\\n\\nY.刷新\\t回车键返回.....\\n\u0026#34;); printf(\u0026#34;----------------\\n键入选择：\u0026#34;); fflush(stdin); if (getchar() == \u0026#39;Y\u0026#39;){ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;第 %d 次刷新成功！\\t\u0026#34;,num_1++); balance_num(); } else system(\u0026#34;cls\u0026#34;); } //取款 void draw(){ void file_read(user*); void file_save(user*,int); void handle_save(struct tm*, float, char arr[]); struct tm* time_now(); struct tm *t = time_now(); int user_num(); int num_2 = 0; float money; user* login(); user *p = login(); user list[user_max] = { NULL }; printf(\u0026#34;\\n--------------\\n金额：\u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;money); if (money \u0026lt;= 0){ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：取款失败，原因金额应大于零！\\t\u0026#34;); } else if (money \u0026gt; (p-\u0026gt;balance)) { system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：取款失败，原因余额不足！\\t\u0026#34;); } else { file_read(list); for (num_2; list[num_2].card != p-\u0026gt;card; num_2++); (p-\u0026gt;balance) -= money; list[num_2].balance = p-\u0026gt;balance; handle_save(t, money, \u0026#34;draw\u0026#34;); file_save(list, user_num()); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：取款成功! 金额：%.2f元\\t\u0026#34;, money); } } //存款 void deposit(){ void file_read(user*); void file_save(user*, int); void handle_save(struct tm*, float, char arr[]); struct tm* time_now(); struct tm *t = time_now(); int user_num(); int num_3 = 0; float money; user* login(); user *p = login(); user list[user_max] = { NULL }; printf(\u0026#34;\\n--------------\\n金额：\u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;money); if (money \u0026lt;= 0){ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：存款失败，原因金额应大于零！\\t\u0026#34;); } else { file_read(list); for (num_3; list[num_3].card != p-\u0026gt;card; num_3++); (p-\u0026gt;balance) += money; list[num_3].balance = p-\u0026gt;balance; handle_save(t, money, \u0026#34;deposit\u0026#34;); file_save(list, user_num()); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：存款成功! 金额：%.2f元\\t\u0026#34;, money); } } //修改密码 void editpass(){ void file_read(user*); void file_save(user*, int); user* login(); int user_num(); void handle_save(struct tm*, float, char arr[]); struct tm* time_now(); struct tm *t = time_now(); user *p = login(); user list[user_max] = { NULL }; char pass[8]; int num_6 = 0; printf(\u0026#34;\\n\\n----------------------\\n\u0026#34;); printf(\u0026#34;*认证/输入原密码：\u0026#34;); fflush(stdin); gets(pass); if (strcmp(p-\u0026gt;pass, pass) == 0){ printf(\u0026#34;输入新密码（6个字符）：\u0026#34;); fflush(stdin); gets(pass); if (strlen(pass) == 6){ file_read(list); for (num_6; list[num_6].card != p-\u0026gt;card; num_6++); strcpy(list[num_6].pass, pass); handle_save(t, 0, \u0026#34;editpass\u0026#34;); file_save(list, user_num()); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：新密码设置成功，以后请使用新密码登录！\\t\u0026#34;); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：修改失败，原因新密码不符合规定！\\t\u0026#34;); } } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：修改失败，原因认证失败！\\t\u0026#34;); } } //名下账户 void account(){ user* login(); user *p = login(); void file_read(user*); user list[user_max] = { NULL }; int user_num(); int num_8 = 0; file_read(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;用户：%s 名下账户\\n\\n\\n\u0026#34;, p-\u0026gt;name); printf(\u0026#34;\\t\\t┌─────┬─────────────────┬─────────────┐\\n\u0026#34;); printf(\u0026#34;\\t\\t│序 号│ 姓 名 │卡 号 │\\n\u0026#34;); for (int i = user_num() - 1; i \u0026gt;= 0; i--, num_8++) if (strcmp(list[i].name, p-\u0026gt;name) == 0){ printf(\u0026#34;\\t\\t├─────┼─────────────────┼─────────────┤\\n\u0026#34;); printf(\u0026#34;\\t\\t│%5d│%17s│%13d│\\n\u0026#34;, i, list[i].name, list[i].card); } printf(\u0026#34;\\t\\t└─────┴─────────────────┴─────────────┘\\n\u0026#34;); printf(\u0026#34;\\t\\t$$共%d条数据\\n\u0026#34;, num_8); printf(\u0026#34;\\n\\n回车键返回......\\n\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } //注销 char del_user(){ user* login(); user *p = login(); int user_num(); void file_read(user*); void file_save(user*, int); user list[user_max] = { NULL }; char pass[8]; int num_7 = 0; if (p-\u0026gt;card != 18072801) { printf(\u0026#34;\\n\\n--------------\\n认证/输入密码：\u0026#34;); fflush(stdin); gets(pass); if (strcmp(p-\u0026gt;pass, pass) == 0){ file_read(list); for (num_7; list[num_7].card != p-\u0026gt;card; num_7++); for (num_7; num_7 \u0026lt; user_num() - 1; num_7++) list[num_7] = list[num_7 + 1]; file_save(list, user_num() - 1); p-\u0026gt;name[0] = NULL; printf(\u0026#34;\\n卡号：%d 注销成功，回车键返回......\\n\u0026#34;, p-\u0026gt;card); fflush(stdin); getchar(); return \u0026#39;Q\u0026#39;; } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：注销失败，原因认证失败！\\t\u0026#34;); return NULL; } } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：默认管理员账户不能注销！\\t\u0026#34;); return NULL; } } //登出系统 char out_login(){ user* login(); user *p = login(); printf(\u0026#34;\\n\\n------------------\\n\u0026#34;); printf(\u0026#34;\\tQ.返回\\t回车键登出系统.......\\n\u0026#34;); fflush(stdin); if (getchar() == \u0026#39;Q\u0026#39;){ system(\u0026#34;cls\u0026#34;); return NULL; } else{ p-\u0026gt;name[0] = NULL; return \u0026#39;Q\u0026#39;; } } //记录查询 void handle_list(){ user* login(); user *p = login(); char h1; struct tm t[2]; printf(\u0026#34;\\n\\n---------------------\\n\\tA.近%d条记录\\tB.按时间段查询\\n\u0026#34;, take_notes_max); printf(\u0026#34;键入序号：\u0026#34;); fflush(stdin); h1 = getchar(); int num_9 = 0; if (h1 == \u0026#39;A\u0026#39;){ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;卡号：%d 最近%d条记录\\n\\n\u0026#34;, p-\u0026gt;card, take_notes_max); for (int i = 0; (i \u0026lt; take_notes_max)\u0026amp;\u0026amp;(p-\u0026gt;list[i].handle[0] != NULL); i++) printf(\u0026#34;##日期：%d年%d月%d日 %d:%d:%d\\n\\t操作：%s\\t金额：%.2f\\n\u0026#34;, 1900 + p-\u0026gt;list[i].T.tm_year, 1 + p-\u0026gt;list[i].T.tm_mon, p-\u0026gt;list[i].T.tm_mday, 8 + p-\u0026gt;list[i].T.tm_hour, p-\u0026gt;list[i].T.tm_min, p-\u0026gt;list[i].T.tm_sec, p-\u0026gt;list[i].handle, p-\u0026gt;list[i].money); printf(\u0026#34;\\n\\n\\n回车键返回........\\n\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } else if (h1 == \u0026#39;B\u0026#39;){ printf(\u0026#34;\\n\\n------------------------\\n输入开始日期（格式：2018-07-29）：\u0026#34;); scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;t[0].tm_year, \u0026amp;t[0].tm_mon, \u0026amp;t[0].tm_mday); printf(\u0026#34;输入结束日期：\u0026#34;); scanf(\u0026#34;%d-%d-%d\u0026#34;, \u0026amp;t[1].tm_year, \u0026amp;t[1].tm_mon, \u0026amp;t[1].tm_mday); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;日期：%d年%d月%d日-%d年%d月%d日 的记录\\n\\n\u0026#34;, t[0].tm_year,t[0].tm_mon, t[0].tm_mday, t[1].tm_year, t[1].tm_mon, t[1].tm_mday); for (int i = 0;( i \u0026lt; take_notes_max)\u0026amp;\u0026amp;(p-\u0026gt;list[i].handle[0] != NULL); i++) if (p-\u0026gt;list[i].T.tm_year \u0026gt;= (t[0].tm_year - 1900) \u0026amp;\u0026amp; p-\u0026gt;list[i].T.tm_mon \u0026gt;= (t[0].tm_mon - 1) \u0026amp;\u0026amp; p-\u0026gt;list[i].T.tm_mday \u0026gt;= t[0].tm_mday) if (p-\u0026gt;list[i].T.tm_year \u0026lt;= (t[1].tm_year - 1900) \u0026amp;\u0026amp; p-\u0026gt;list[i].T.tm_mon \u0026lt;= (t[1].tm_mon - 1) \u0026amp;\u0026amp; p-\u0026gt;list[i].T.tm_mday \u0026lt;= t[1].tm_mday) { printf(\u0026#34;##日期：%d年%d月%d日 %d:%d:%d\\n\\t操作：%s\\t金额：%.2f\\n\u0026#34;, 1900 + p-\u0026gt;list[i].T.tm_year, 1 + p-\u0026gt;list[i].T.tm_mon, p-\u0026gt;list[i].T.tm_mday, 8 + p-\u0026gt;list[i].T.tm_hour, p-\u0026gt;list[i].T.tm_min, p-\u0026gt;list[i].T.tm_sec,p-\u0026gt;list[i].handle,p-\u0026gt;list[i].money); num_9++; } printf(\u0026#34;\\n\\n$$共%d条记录\\n\u0026#34;, num_9); printf(\u0026#34;\\n\\n回车键返回.......\\n\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：选择错误，重新选择！\\t\u0026#34;); } } //转账 void cover(){ user* login(); void file_read(user*); void file_save(user*, int); int user_num(); user *p = login(); user list[user_max] = { NULL }; int card; float money, F; printf(\u0026#34;\\n\\n----------------\\n收款人卡号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;card); file_read(list); for (int i = user_num() - 1; i \u0026gt;= 0; i--) if (list[i].card == card){ int ii = strlen(list[i].name); printf(\u0026#34;##收款人：%s\\n\u0026#34;, list[i].name); printf(\u0026#34;$$输入转账金额：\u0026#34;); scanf(\u0026#34;%f\u0026#34;, \u0026amp;money); if (money \u0026gt;= 0 \u0026amp;\u0026amp; money \u0026lt;= p-\u0026gt;balance){ printf(\u0026#34;\\tY.确认转账\\t回车键取消.........\\n\u0026#34;); printf(\u0026#34;键入选择：\u0026#34;); fflush(stdin); if (getchar() == \u0026#39;Y\u0026#39;){ for (ii = user_num() - 1; ii \u0026gt;= 0 \u0026amp;\u0026amp; (list[ii].card != p-\u0026gt;card); ii--); list[i].balance += money; p-\u0026gt;balance -= money; list[ii].balance = p-\u0026gt;balance; file_save(list, user_num()); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：转账成功！ 收款人：%d 金额：%.2f\\t\u0026#34;, card, money); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示:取消转账！\\t\u0026#34;); } } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：余额不足，转账失败！\\t\u0026#34;); } card = 0; break; } if (card != 0){ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：转账失败，原因不存在的收款人！\\t\u0026#34;); } } //用户列表，管理员 void user_list(){ user* login(); user *p = login(); void file_read(user*); void file_save(user*, int); int user_num(); int user_u; char h1; user list[user_max] = { NULL }; if (p-\u0026gt;card == 18072801){ printf(\u0026#34;欢迎管理员%s\\t卡号：%d\\n\u0026#34;, p-\u0026gt;name, p-\u0026gt;card); file_read(list); printf(\u0026#34;\\n\\n\u0026#34;); printf(\u0026#34;\\t┌──────┬───────────────┬───────────┬────────────┐\\n\u0026#34;); printf(\u0026#34;\\t│序号 │姓名 │卡号 │余额 │\\n\u0026#34;); for (int i = user_num() - 1; i \u0026gt;= 0; i--) if (list[i].card != 18072801){ printf(\u0026#34;\\t├──────┼───────────────┼───────────┼────────────┤\\n\u0026#34;); printf(\u0026#34;\\t│%6d│%15s│%11d│%12.2f│\\n\u0026#34;, i, list[i].name, list[i].card, list[i].balance); } printf(\u0026#34;\\t└──────┴───────────────┴───────────┴────────────┘\\n\u0026#34;); printf(\u0026#34;\\t\\t$$共有%d条数据\\n\u0026#34;, user_num() - 1); printf(\u0026#34;\\n\\n--------------------\\n对用户操作：\\n\\tA.修改密码\\tB.删除用户\\t回车键返回上一级.......\\n\u0026#34;); printf(\u0026#34;键入序号：\u0026#34;); fflush(stdin); h1 = getchar(); if (h1 == \u0026#39;A\u0026#39; || h1 == \u0026#39;B\u0026#39;) { printf(\u0026#34;操作用户的序号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;user_u); if (user_u \u0026gt;= 0 \u0026amp;\u0026amp; user_u \u0026lt;= (user_num() - 1)) { if (h1 == \u0026#39;A\u0026#39;){ printf(\u0026#34;输入新密码：\u0026#34;); fflush(stdin); gets(list[user_u].pass); file_save(list, user_num()); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;卡号：%d 密码修改成功！\\t\u0026#34;,list[user_u].card); user_list(); } else{ printf(\u0026#34;Y.确定删除\\t回车键返回.......\\n\u0026#34;); fflush(stdin); if (getchar() == \u0026#39;Y\u0026#39;){ for (int i = user_num() - 1; i \u0026gt; user_u; user_u++) list[user_u] = list[user_u + 1]; file_save(list, user_num() - 1); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：删除成功！\\t\u0026#34;); user_list(); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：放弃删除操作！\\t\u0026#34;); user_list(); } } } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：操作失败，原因不存在该序号！\\t\u0026#34;); user_list(); } } else system(\u0026#34;cls\u0026#34;); } } //时间函数,获取当前时间 /*tm返回UTC时间，转换北京时间year+1900,mon+1,hour+8*/ struct tm* time_now(){ struct tm *p; time_t *timep = (time_t*)malloc(sizeof(time_t)); time(timep); p = gmtime(timep); free(timep); return p; } //操作记录 void handle_save(struct tm *t, float money,char arr[10]){ void file_read(user*); void file_save(user*, int); int user_num(); user* login(); user *p = login(); user *p1 = (user*)calloc(user_max, user_size); int num_4 = 0; for (num_4; p-\u0026gt;list[num_4].handle[0] != NULL; num_4++);\t//取得已存条数 if (num_4 == take_notes_max){ for (int i = 0; i \u0026lt; num_4; i++) p-\u0026gt;list[i] = p-\u0026gt;list[i + 1]; } strcpy(p-\u0026gt;list[num_4].handle, arr); p-\u0026gt;list[num_4].T = *t; p-\u0026gt;list[num_4].money = money; file_read(p1); for (num_4 = 0; (p1 + num_4)-\u0026gt;card != p-\u0026gt;card; num_4++); *(p1 + num_4) = *p; file_save(p1, user_num()); free(p1); } //用户数量 int user_num(){ void file_read(user*); int num_5 = 0; user list[user_max] = { NULL }; file_read(list); while ((list[num_5].name[0]) != NULL) num_5++; return num_5; } //加密 void data_j(user *p){ for (int i = 0; i \u0026lt; strlen(p-\u0026gt;name); i++) p-\u0026gt;name[i] += 2; for (int i = 0; i \u0026lt; 6; i++) p-\u0026gt;pass[i] += 5; } //解密 void data_i(user *p){ for (int i = 0; i \u0026lt; strlen(p-\u0026gt;name); i++) p-\u0026gt;name[i] -= 2; for (int i = 0; i \u0026lt; 6; i++) p-\u0026gt;pass[i] -= 5; } 4. 数据操作文件（datalink.cpp） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* **文件操作 **ASorb time:201807 */ #include\u0026#34;banksystem.h\u0026#34; //文件检测 void file_true(){ void file_save(user*, int); FILE *data = fopen(data_file, \u0026#34;rb\u0026#34;); if (data == NULL){ user p={NULL}; strcpy(p.name,\u0026#34;asorb\u0026#34;); p.card=18072801; strcpy(p.pass,\u0026#34;123456\u0026#34;); p.balance=100;\t//定义一条测试数据 file_save(\u0026amp;p, 1);\t//保存测试的数据 } else fclose(data); } //写入文件 void file_save(user *p, int count) { void data_j(user*); for (int i = 0; i \u0026lt; count; i++) data_j(p + i); FILE *data = fopen(data_file, \u0026#34;wb\u0026#34;); fwrite(p, user_size, count, data); fclose(data); } //读取文件 void file_read(user *p){ void data_i(user*); FILE *data = fopen(data_file, \u0026#34;rb\u0026#34;); fread(p, user_size, user_max, data); for (int i = 0; (p + i)-\u0026gt;name[0] != NULL; i++) data_i(p + i); fclose(data); } 5. 界面文件（interface.cpp） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 /* **显示菜单 **ASorb time:201807 */ #include\u0026#34;banksystem.h\u0026#34; //初始化窗口 void face(){ system(\u0026#34;title 银行系统实例\u0026#34;); system(\u0026#34;color 2F\u0026#34;); } //初始界面 char face_1(){ char h1; printf(\u0026#34;\\nAuthor:ASorb\\tTime:201807\u0026#34;); printf(\u0026#34;\\n\\n\\n\\n\\n\\n\\t\\t\\tA.进入系统\\tB.新用户\\n\\n\\t\\t\\tQ.退出系统\\n\u0026#34;); printf(\u0026#34;\\n\\n---------------\\n键入序号：\u0026#34;); fflush(stdin);\t//清除输入缓存 h1 = getchar(); if (h1 == \u0026#39;A\u0026#39; || h1 == \u0026#39;B\u0026#39; || h1 == \u0026#39;Q\u0026#39;) return h1; else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：选择有误，重新选择！\u0026#34;); } } //登录后界面 void face_2(){ user* login(); user *p = login(); void balance_num(); void draw(); void deposit(); void editpass(); void account(); char del_user(); char out_login(); void handle_list(); void user_list(); void cover(); char h1; while (1){ printf(\u0026#34;欢迎用户：%s\\n\u0026#34;, p-\u0026gt;name); printf(\u0026#34;\\n\\n\\n\\n\\t\\t\\tA.余额查询\\tB.取款\\n\u0026#34;); printf(\u0026#34;\\n\\t\\t\\tC.修改密码\\tD.存款\\n\u0026#34;); printf(\u0026#34;\\n\\t\\t\\tE.名下账户\\tF.注销\\n\u0026#34;); printf(\u0026#34;\\n\\t\\t\\tG.登出系统\\tH.记录\\n\u0026#34;); printf(\u0026#34;\\n\\t\\t\\tQ.返回上一级\\tI.转账\\n\u0026#34;); if (p-\u0026gt;card == 18072801) printf(\u0026#34;\\n\\t\\t\\t\\tU.用户列表*\\n\u0026#34;); printf(\u0026#34;\\n----------------\\n键入序号：\u0026#34;); fflush(stdin); if ((h1 = getchar()) \u0026gt;= \u0026#39;A\u0026#39;\u0026amp;\u0026amp;h1 \u0026lt;= \u0026#39;I\u0026#39;){ switch (h1){ case \u0026#39;A\u0026#39;: system(\u0026#34;cls\u0026#34;); balance_num(); break; case \u0026#39;B\u0026#39;: draw(); break; case \u0026#39;C\u0026#39;: editpass(); break; case \u0026#39;D\u0026#39;: deposit(); break; case \u0026#39;E\u0026#39;: account(); break; case \u0026#39;F\u0026#39;: h1 = del_user(); break; case \u0026#39;G\u0026#39;: h1 = out_login(); break; case \u0026#39;H\u0026#39;: handle_list(); break; case \u0026#39;I\u0026#39;: cover(); } if (h1 == \u0026#39;Q\u0026#39;){ system(\u0026#34;cls\u0026#34;); break; } } else if (h1 == \u0026#39;Q\u0026#39;){ system(\u0026#34;cls\u0026#34;); break; } else if (h1 == \u0026#39;U\u0026#39;){ system(\u0026#34;cls\u0026#34;); user_list(); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：选择有误，重新选择！\\n\u0026#34;); } } } 效果图 下载地址 DEVC++下测试工程文件（源代码）：https://download.csdn.net/download/qq_42304721/10592413\n","date":"2023-08-11T23:56:01+08:00","image":"https://c-poet.github.io/post/coding/c/bank-manage-system-by-c/screenshot_hu351a789752f968e59a7ba2b3bdc5bb46_182714_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/coding/c/bank-manage-system-by-c/","title":"银行管理系统实例(C语言版）"},{"content":"应用服务 配置方式 在Linux服务器中，应用服务可以通过Linux的“服务管理器”进行统一管理。在应用部署时只需要在/etc/systemd/system或/etc/systemd/user目录下编写如下格式的service文本即可将服务交由systemctl管理。\n1 2 3 4 5 6 7 8 9 10 # demo.service [Unit] # 服务描述\tDescription=演示示例服务 [Service] # 定义执行的命令 ExecStart=java -jar /opt/*.jar # 指定执行命令的用户 User=deamon 注意： 建议使用限权的用户（例如：deamon）来启动应用服务以提升系统安全性。\n常用命令 使用systemctl命令时需要进行提权，可以使用su命令切换到高权限用户或者使用sudo命令进行提权。\n1 2 3 4 5 6 7 8 9 10 11 12 # 启动服务 systemctl start [demo.service] # 停止服务 systemctl stop [demo.service] # 重启服务 systemctl restart [demo.service] # 服务状态 systemctl status [demo.service] # 开机自启 systemctl enable [demo.service] # 关闭自启 systemctl disable [demo.service] 补充说明 多数情况下都是通过应用日志来排查应用问题，但是存在极少数的非运行时问题，比如：应用的路径配置不正确。这种问题可以通过systemctl status进行初步问题的排查，更多日志信息可以通过监听/var/log/messages文件来获取。\n1 2 # eg: 查看服务日志 sudo tail -900f /var/log/messages 应用日志 要求说明 统一应用日志管理几点要求：\n统一输出目录； 统一日志格式规范（例如：分warn级别和info级别的日志）； 日志自动压缩和自动清理。 统一日志目录和格式规范的话，对于运维人员和开发人员都可以快速的提取和分析日志。（就算应用不是自己部署的情况下，也可以在约定的目录找到服务运行日志）。很多情况下，日志是帮助运维、开发人员分析现有问题的工具，那么历史日志的价值就会很低，因此建议保留15至30天的日志即可。\nlogback配置示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--读取SpringBoot中的配置--\u0026gt; \u0026lt;!-- 日志输出路径 --\u0026gt; \u0026lt;springProperty scope=\u0026#34;context\u0026#34; name=\u0026#34;logRoot\u0026#34; source=\u0026#34;logging.file.path\u0026#34;/\u0026gt; \u0026lt;!-- 应用名称，作为日志文件的特征符号 --\u0026gt; \u0026lt;springProperty scope=\u0026#34;context\u0026#34; name=\u0026#34;logModule\u0026#34; source=\u0026#34;spring.application.name\u0026#34;/\u0026gt; \u0026lt;!-- 警告及以上级别的日志 --\u0026gt; \u0026lt;appender name=\u0026#34;FILE_WARN\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;filter class=\u0026#34;ch.qos.logback.classic.filter.LevelFilter\u0026#34;\u0026gt; \u0026lt;level\u0026gt;WARN\u0026lt;/level\u0026gt; \u0026lt;onMatch\u0026gt;ACCEPT\u0026lt;/onMatch\u0026gt; \u0026lt;onMismatch\u0026gt;DENY\u0026lt;/onMismatch\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;file\u0026gt;${logRoot}/${logModule}-warn.log\u0026lt;/file\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;${logRoot}/${logModule}-warn-%d{yyyy-MM-dd}.log.zip\u0026lt;/fileNamePattern\u0026gt; \u0026lt;maxHistory\u0026gt;360\u0026lt;/maxHistory\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{50} [%file:%line] -%msg %n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 所有级别的日志 --\u0026gt; \u0026lt;appender name=\u0026#34;FILE_ALL\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;file\u0026gt;${logRoot}/${logModule}-all.log\u0026lt;/file\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;${logRoot}/${logModule}-all-%d{yyyy-MM-dd}.log.zip\u0026lt;/fileNamePattern\u0026gt; \u0026lt;maxHistory\u0026gt;36\u0026lt;/maxHistory\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{50} [%file:%line] -%msg %n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 应用配置 --\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE_WARN\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE_ALL\u0026#34;/\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; Spring Boot配置 1 2 3 4 5 6 logging: # 指定配置文件 config: logback.xml file: # 指定日志输出目录 path: /data/logs nginx配置 1 2 3 4 5 6 7 8 9 10 11 12 # 错误级别的日志输出 error_log /data/logs error; http { # 日志格式 log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; # 访问日志输出，指定输出目录和日志格式 access_log /data/logs main; } 日志变量说明：\n1 2 3 4 5 6 7 8 9 $remote_addr ：记录访问网站的客户端地址 $remote_user ：记录远程客户端用户名称 $time_local ：记录访问时间与时区 $request ：记录用户的 http 请求起始行信息 $status ：记录 http 状态码，即请求返回的状态，例如 200 、404 、502 等 $body_bytes_sent ：记录服务器发送给客户端的响应 body 字节数 $http_referer ：记录此次请求是从哪个链接访问过来的，可以根据 referer 进行防盗链设置 $http_user_agent ：记录客户端访问信息，如浏览器、手机客户端等 $http_x_forwarded_for ：当前端有代理服务器时，设置 Web 节点记录客户端地址的配置，此参数生效的前提是代理服务器上也进行了相关的 x_forwarded_for 设置 ","date":"2022-07-14T20:53:50+08:00","permalink":"https://c-poet.github.io/post/linux/linux-service-log-manage/","title":"Linux服务器统一应用服务管理和统一应用日志管理"},{"content":"前言 现实开发中经常遇到Pojo间的转换，手动写Conversion方法过于繁琐，而且代码中也会有很多冗余代码。为了偷懒干脆直接使用BeanUtils.copyProperties方法，可是每次结合lambda和链式时，总觉得直接使用BeanUtils中断链式不太舒服，因此封装了Transformer类。\nTransformer类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 /** * POJO转换便捷类 * * @author wanggf */ public final class Transformer\u0026lt;SOURCE, TARGET\u0026gt; { private final Supplier\u0026lt;TARGET\u0026gt; supplier; private BiConsumer\u0026lt;SOURCE, TARGET\u0026gt; consumer; /** * 构造器 * * @param supplier 目标对象工厂 */ public Transformer(Supplier\u0026lt;TARGET\u0026gt; supplier) { this.supplier = supplier; } /** * 自定义填充方法 * \u0026lt;p\u0026gt;链式使用该填充方法时需注意，如果编译器无法推断出{@link SOURCE}的类型，则可以显式指示该类型。\u0026lt;/p\u0026gt; * \u0026lt;pre\u0026gt;new Transformer\u0026amp;lt;User, UserVo\u0026amp;get;(UserVo::new).fill((s, t) -\u0026gt; t.setUserId(s.getUserId))\u0026lt;/pre\u0026gt; * * @param consumer 填充方法 * @return 便捷类实例 */ public Transformer\u0026lt;SOURCE, TARGET\u0026gt; fill(BiConsumer\u0026lt;SOURCE, TARGET\u0026gt; consumer) { this.consumer = this.consumer == null ? consumer : this.consumer.andThen(consumer); return this; } /** * 自定义填充方法 * * @param consumer 填充方法 * @return 便捷类实例 */ public Transformer\u0026lt;SOURCE, TARGET\u0026gt; fill(Consumer\u0026lt;TARGET\u0026gt; consumer) { return fill((s, t) -\u0026gt; consumer.accept(t)); } /** * 目标转换 * * @param map 转换方法 * @param \u0026lt;T\u0026gt; 目标类型 * @return 新构造的便捷类实例 */ public \u0026lt;T\u0026gt; Transformer\u0026lt;TARGET, T\u0026gt; map(Function\u0026lt;TARGET, T\u0026gt; map) { return new Transformer\u0026lt;\u0026gt;(() -\u0026gt; map.apply(supplier.get())); } /** * 执行转换 * * @param source 源对象 * @return 目标对象 */ public TARGET transform(SOURCE source) { TARGET target = supplier.get(); if (target != null \u0026amp;\u0026amp; source != null) { BeanUtils.copyProperties(source, target); if (consumer != null) { consumer.accept(source, target); } } return target; } /** * 执行转换，并返回{@link Optional}对象 * * @param source 源对象 * @return {@link Optional} */ public Optional\u0026lt;TARGET\u0026gt; transformDoOpt(SOURCE source) { return Optional.ofNullable(transformTo(source)); } } 示例 Transformer单对象转换 1 2 3 4 5 6 7 8 9 10 11 public CategoryVo getById(Long id) { Category category = iCategoryService.getById(id); if (category == null) { throw new RequestException(MostReturnStatus.NONEXISTENT_RESOURCE, \u0026#34;文章分类不存在\u0026#34;); } return new Transformer\u0026lt;\u0026gt;(CategoryVo::new).fill(t -\u0026gt; { if (!Objects.equals(t.getParentId(), DataDefaultValueConst.DEFAULT_PARENT_ID)) { t.setParentName(getCategoryNameById(t.getParentId())); } }).transform(category); } Transformer集合转换 1 2 3 4 5 6 7 8 9 public PageVo\u0026lt;PersonCategoryVo\u0026gt; listByTerm(CategoryParam categoryParam, PageParam pageParam, Subject subject) { PageVo\u0026lt;Category\u0026gt; categories = iCategoryService .listByName(categoryParam.getName(), subject.getUid(), pageParam.getDecrPage(), pageParam.getSize()); return categories.map(new Transformer\u0026lt;\u0026gt;(PersonCategoryVo::new).fill(t -\u0026gt; { if (!Objects.equals(t.getParentId(), DataDefaultValueConst.DEFAULT_PARENT_ID)) { t.setParentName(getCategoryNameById(t.getParentId())); } })::transform); } ","date":"2022-01-08T21:01:24+08:00","permalink":"https://c-poet.github.io/post/coding/java/pojo-transform-util/","title":"优雅的Pojo转换类封装，基于BeanUtils的链式封装（Transformer类）"},{"content":"前言 目前poi-tl只提供了word表格的单行模板渲染能力，但是在实际的开发中，业务需求涉及多行，这里就需要自己编写一个渲染策略。\n正文 因为poi-tl使用指定策略的方式为通过ConfigureBuilder的bind方式指定处理某个参数的变量，比如这样：\n1 2 ConfigureBuilder builder = Configure.builder(); builder.bind(\u0026#34;reports\u0026#34;, new MultipleRowTableRenderPolicy()); 所以第一步需要获取reports所在的行位置。\n1 2 3 4 protected int getRowIndex(XWPFTableRow row) { List\u0026lt;XWPFTableRow\u0026gt; rows = row.getTable().getRows(); return rows.indexOf(row); } 由于是多行渲染，因此需要知道定义的模板行数。\n1 2 3 4 5 6 7 8 9 10 11 12 protected int getMultipleRowNum(XWPFTemplate template) throws CloneNotSupportedException { TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(multiplePrefix, multipleSuffix)); List\u0026lt;MetaTemplate\u0026gt; metaTemplates = resolver.resolveDocument(template.getXWPFDocument()); if (!metaTemplates.isEmpty()) { RunTemplate run = cast2runTemplate(metaTemplates.get(0)); String tagName = run.getTagName(); int num = Integer.parseInt(tagName); run.getRun().setText(\u0026#34;\u0026#34;, 0); return num \u0026lt; 1 ? DEFAULT_MULTIPLE_ROW_NUM : num; } return DEFAULT_MULTIPLE_ROW_NUM; } 拿到基本信息后就可以遍历数据，进而遍历渲染表格了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 run.setText(\u0026#34;\u0026#34;, 0); TemplateResolver resolver = new TemplateResolver(template.getConfig().copy(prefix, suffix)); // 获取模板所在的起始行 int position = getRowIndex(tagCell.getTableRow()); List\u0026lt;XWPFTableRow\u0026gt; tempRows = getAllTemplateRow(table, template, position); // 保存第行模板，以便在后续操作中获取光标 final XWPFTableRow firstTempRow = tempRows.get(0); Iterator\u0026lt;?\u0026gt; dataIt = ((Iterable\u0026lt;?\u0026gt;) data).iterator(); boolean hasNextData = dataIt.hasNext(); int index = 0; while (hasNextData) { Object dt = dataIt.next(); hasNextData = dataIt.hasNext(); Iterator\u0026lt;XWPFTableRow\u0026gt; rowTempIt = tempRows.iterator(); boolean hasNextTempRow = rowTempIt.hasNext(); while (hasNextTempRow) { XWPFTableRow tempRow = rowTempIt.next(); hasNextTempRow = rowTempIt.hasNext(); if (!table.addRow(tempRow, position)) { throw new RenderException(\u0026#34;创建新的表格行失败\u0026#34;); } // 光标操作，移动光标到目标行，以便后续的模板渲染 XmlCursor newCursor = firstTempRow.getCtRow().newCursor(); newCursor.toPrevSibling(); XmlObject object = newCursor.getObject(); XWPFTableRow newRow = new XWPFTableRow((CTRow) object, table); newRow.getCtRow().set(object); setTableRow(table, newRow, position); List\u0026lt;XWPFTableCell\u0026gt; cells = newRow.getTableCells(); RenderDataCompute dataCompute = template.getConfig().getRenderDataComputeFactory() .newCompute(EnvModel.of(dt, EnvIterator.makeEnv(index++, hasNextData || hasNextTempRow))); cells.forEach(tableCell -\u0026gt; { List\u0026lt;MetaTemplate\u0026gt; metaTemplates = resolver.resolveBodyElements(tableCell.getBodyElements()); new DocumentProcessor(template, resolver, dataCompute).process(metaTemplates); }); ++position; } } removeTableRow(table, position, tempRows.size()); 值得一提就是光标的移动操作，相当于操作所有行的确定。取模板的第一行作为基位置，然后每次插入的渲染的行后，就把光标向上移一行，进而指向刚插入的行，最后渲染即可。\nEnvIterator.makeEnv只是为了生成一些遍历现在时参数，可以用在渲染参数的表达式中，具体可以参数poi-tl的文档。\n附上removeTableRow函数的实现，注意：使用下标移出行时，下标千万不要作自增操作。\n1 2 3 4 5 protected void removeTableRow(XWPFTable table, int startIndex, int size) { for (int i = 0; i \u0026lt; size; ++i) { table.removeRow(startIndex); } } 测试 模板 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class MultipleRowTableRenderPolicyTest { public static void main(String[] args) throws IOException { Map\u0026lt;String, Object\u0026gt; params = new HashMap\u0026lt;\u0026gt;(); params.put(\u0026#34;title\u0026#34;, \u0026#34;某某某会议\u0026#34;); params.put(\u0026#34;date\u0026#34;, new Date()); params.put(\u0026#34;address\u0026#34;, \u0026#34;某某会议室\u0026#34;); List\u0026lt;Report\u0026gt; reports = new ArrayList\u0026lt;\u0026gt;(); reports.add(new Report(\u0026#34;王五\u0026#34;, new Date(), \u0026#34;汇报内容1\u0026#34;)); reports.add(new Report(\u0026#34;张三\u0026#34;, new Date(), \u0026#34;汇报内容2\u0026#34;)); reports.add(new Report(\u0026#34;李四\u0026#34;, new Date(), \u0026#34;汇报内容3\u0026#34;)); params.put(\u0026#34;reports\u0026#34;, reports); ConfigureBuilder builder = Configure.builder(); builder.bind(\u0026#34;reports\u0026#34;, new MultipleRowTableRenderPolicy()); XWPFTemplate xt = XWPFTemplate .compile(\u0026#34;src/test/resources/template/render-multiple-row.docx\u0026#34;, builder.build()) .render(params); xt.writeToFile(\u0026#34;render-multiple-row.docx\u0026#34;); } static class Report { private String author; private Date time; private String content; public Report(String author, Date time, String content) { this.author = author; this.time = time; this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public Date getTime() { return time; } public void setTime(Date time) { this.time = time; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } } 结语 相关代码已经上传至github，地址：GitHub - c-poet/poi-tl-ext: poi-tl扩展\n","date":"2021-06-26T21:06:42+08:00","permalink":"https://c-poet.github.io/post/mixeds/poi-tl-ext-custom/","title":"poi-tl-ext扩展，实现多行表格模板替换"},{"content":"功能要求 当输入student.sh时，输出文件的全部内容 当输入student.sh –h 5时，输出文件的前5条记录;当输入student.sh -t 5时，输出文件的最后5条记录; 当输入student.sh –o num，输出文件的全部内容,并按学号升序排序;输入student.sh -o dep，输出文件的全部内容,并按系别排序; 当输入student.sh -a 00101:张三:男:计算机 时，首先判断00101记录是否存在;如果存在，则给出提示，并输出文件中学号为00101的该行信息;如果不存在，判断该行信息是否符合格式要求(各个字段不能为空;学号必须是5个数字;性别的取值只能是”男”和”女”）,如果不符合要求，则提示用户信息格式不对;否则把该信息写入文件student.txt。 当输入student.sh -d 00101(或student.sh - d 张三）时，首先判断00101（或张三）记录是否存在，如果不存在，给出提示;如果存在，显示该行信息并提示用户确认是否要删除记录，如用户输入y或者yes，则删除文件中学号为00101的该行信息，如果用户输入n或no时，则不做删除操作 当输入student.sh -s 00101(或student.sh -s 张三）时，首先判断00101(或张三）记录是否存在，如果不在，给出提示，如果存在，则输出文件中00101（或张三）的该行信息 当输入student.sh \u0026ndash;help时;输出该shell的用法 当用户输入的选项不正确时，给出错误提示，并输出该shell的用法（如:student.sh -q 123456 需错误提示) 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 #!/bin/bash # 简单学生成绩管理系统 # -- linux 系统课程作业 # -- By llZero # -- 2020年11月 # final _TRUE=1 _FALSE=0 # 数据文件名称 DATA_FILE_NAME=\u0026#39;student.txt\u0026#39; # 判断数据格式是否符合要求 function fun_test_data_format { if test 1 -eq `echo $1|grep -c -e \u0026#39;^[0-9]\\{5\\}:[^:]\\{1,\\}:[男女]:[^:]\\{1,\\}$\u0026#39;` then return $_TRUE fi return $_FALSE } # 个性化输出 function echo_erro { echo -e \u0026#34;\\033[31m $1 \\033[0m\u0026#34; } function echo_info { echo $1 } # 打印帮助 function fun_show_help { echo_info \u0026#39;[1].-h [num]将显示前num行数据\u0026#39; echo_info \u0026#39;[2].-t [num]将显示后num行数据\u0026#39; echo_info \u0026#39;[3].-o num按学号升序排序输出，-o dep按系别排序\u0026#39; echo_info \u0026#39;[4].-a 追加内容，存在则输出\u0026#39; echo_info \u0026#39;[5].-d 删除数据\u0026#39; echo_info \u0026#39;[6].-s 查看信息\u0026#39; echo_info \u0026#39;[7].--help 打印帮助\u0026#39; echo_info \u0026#39;**如需打印所有信息，则无需加任何选项\u0026#39; } # 判断数据文件是否存在 # 存在则判断数据文件的正确性 # 不存在则会初始化一个文件 if [ -f $DATA_FILE_NAME ] then for line in `cat $DATA_FILE_NAME` do fun_test_data_format $line if test $_TRUE -ne $? then echo_erro \u0026#39;已存在的数据格式不正确，建议删除已有的错误文件！\u0026#39; exit fi done else echo_info \u0026#39;数据文件不存在，自动创建\u0026#39; echo \u0026#39;00101:张三:男:计算机\u0026#39; \u0026gt; $DATA_FILE_NAME fi # 功能选择 case $1 in \u0026#39;-h\u0026#39;) if test -z \u0026#34;$2\u0026#34; then head $DATA_FILE_NAME else head -n $2 $DATA_FILE_NAME fi ;; \u0026#39;-t\u0026#39;) if test -z \u0026#34;$2\u0026#34; then tail $DATA_FILE_NAME else tail -n $2 $DATA_FILE_NAME fi ;; \u0026#39;-o\u0026#39;) if test $2 == \u0026#39;num\u0026#39; then sort --field-separator=\u0026#34;:\u0026#34; --key=1 $DATA_FILE_NAME else sort --field-separator=\u0026#34;:\u0026#34; --key=4 $DATA_FILE_NAME fi ;; \u0026#39;-a\u0026#39;) if test -n \u0026#34;$2\u0026#34; then student_id=`echo $2|cut -d \u0026#39;:\u0026#39; -f 1` if test 1 -eq `grep -c -e \u0026#34;^$student_id:\u0026#34; $DATA_FILE_NAME` then echo_info \u0026#39;学生已存在！！\u0026#39; echo_info `grep -m 1 -e \u0026#34;^$student_id:\u0026#34; $DATA_FILE_NAME` else fun_test_data_format $2 if test $_TRUE -eq $? then echo $2 \u0026gt;\u0026gt; $DATA_FILE_NAME else echo_erro \u0026#39;输入的学生信息格式不符合要求！\u0026#39; fi fi else echo_erro \u0026#39;信息不完整\u0026#39; fi ;; \u0026#39;-d\u0026#39;) if test -n \u0026#34;$2\u0026#34; then if test 1 -eq `grep -c -e \u0026#34;^$2:\u0026#34; $DATA_FILE_NAME` then read -p \u0026#39;是否确定删除[y/n]：\u0026#39; input if test $input == \u0026#39;yes\u0026#39; -o $input == \u0026#39;y\u0026#39; then sed -i \u0026#34;/^$2:/g\u0026#34; $DATA_FILE_NAME fi else echo_erro \u0026#39;学生信息不存在\u0026#39; fi else echo_erro \u0026#39;缺少学号\u0026#39; fi ;; \u0026#39;-s\u0026#39;) if test -n \u0026#34;$2\u0026#34; then if test 1 -eq `grep -c -e \u0026#34;^$2:\u0026#34; $DATA_FILE_NAME` then echo_info `grep -m 1 -e \u0026#34;^$2:\u0026#34; $DATA_FILE_NAME` else echo_erro \u0026#39;学生信息不存在\u0026#39; fi else echo_erro \u0026#39;缺少学号\u0026#39; fi ;; \u0026#39;--help\u0026#39;) fun_show_help ;; \u0026#39;\u0026#39;) cat $DATA_FILE_NAME ;; *) echo_erro \u0026#39;参数选项错误，--help查看帮助\u0026#39; echo_info \u0026#39;------------------------------\u0026#39; fun_show_help ;; esac 效果截图 ","date":"2020-11-15T21:29:13+08:00","image":"https://c-poet.github.io/post/coding/shell/student-score-manage/20201115194746955_hu7f62e071036073fb384a5d265dc7ddd6_169891_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/coding/shell/student-score-manage/","title":"使用shell编写“学生成绩管理系统“，按照要求完成相应的功能。"},{"content":"pip安装mysqliclient报错 fatal error C1083: 无法打开包括文件: “mysql.h”: No such file or directory 出现这个错误的原因是本地没有配置mysql-connector-c的path，也就是说mysqlclient依赖的头文件是lib库没有找到。\n注意：我本地安装的是visual studio 2019\n下载mysql-connector的c语言api 下载地址：https://downloads.mysql.com/archives/c-c/\n我下载的是Windows (x86, 64-bit), ZIP Archive版，如果下载MSI Installer安装版，可以直接安装以省去下面的步骤。\n解压缩后把include的所有头文件复制到Visual studio的MSVC编译器的include中 把mysqlclient.lib更名为mariadbclient.lib，然后把mariadbclient.lib复制到MSVC的lib中（由于我的是64bit，因此我放在x64中） 需要注意自己的路径\n安装mysqlclient 1 pip install -U mysqlclient Successfully!!!!\n","date":"2020-10-16T22:14:59+08:00","image":"https://c-poet.github.io/post/coding/python/pip-install-mysqliclient-c1083/20201016104707626_hu160ed6e0cc4b750f21255d0c9bce01f9_96267_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/coding/python/pip-install-mysqliclient-c1083/","title":"pip安装mysqliclient报错  fatal error C1083: 无法打开包括文件: “mysql.h”: No such file or directory"},{"content":"Python使用requests发起请求体格式为multipart/form-data的请求 直接使用request可能遇见后端拿不到参数的情况，我遇见的错误为error_message': 'MISSING_ARGUMENTS: api_key。\n解决方案是使用requests_toolbelt先处理数据格式，在使用requests进行请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import requests as req from requests_toolbelt.multipart.encoder import MultipartEncoder import inc.config as conf import base64 import io img_file = io.open(\u0026#39;../resource/img2.jpg\u0026#39;, \u0026#39;rb\u0026#39;) img_base64 = base64.encodebytes(img_file.read()) # 请求数据 req_data = {\u0026#39;api_key\u0026#39;: conf.API_KEY, \u0026#39;api_secret\u0026#39;: conf.API_SECRET, \u0026#39;image_base64\u0026#39;: img_base64, \u0026#39;return_attributes\u0026#39;: \u0026#39;age,gender\u0026#39;} # 这里是重点 multipart = MultipartEncoder(req_data) headers = {\u0026#39;Content-Type\u0026#39;: multipart.content_type} res = req.post(conf.faceApi.DETECT_API, req_data, headers=headers) print(res.json()) img_file.close() ","date":"2020-10-15T22:25:18+08:00","image":"https://c-poet.github.io/post/coding/python/requests-missing-arguments/20201015153442930_hucf1fc142931910aacd7b79374a62957b_30578_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/coding/python/requests-missing-arguments/","title":"Python使用requests发起请求体格式为multipart/form-data的请求，解决MISSING_ARGUMENTS"},{"content":"步骤 添加最新稳定版的i3wm软件源信息 1 2 3 4 5 6 7 ~$ su - ~# /usr/lib/apt/apt-helper download-file https://debian.sur5r.net/i3/pool/main/s/sur5r-keyring/sur5r-keyring_2020.02.03_all.deb keyring.deb SHA256:c5dd35231930e3c8d6a9d9539c846023fe1a08e4b073ef0d2833acd815d80d48 ~# dpkg -i ./keyring.deb ~# echo \u0026#34;deb https://debian.sur5r.net/i3/ $(grep \u0026#39;^DISTRIB_CODENAME=\u0026#39; /etc/lsb-release | cut -f2 -d=) universe\u0026#34; \u0026gt;\u0026gt; /etc/apt/sources.list.d/sur5r-i3.list 更新ubuntu本地源信息 1 ~#apt update 安装i3wm 1 ~#apt install i3 进入i3wm 执行reboot重启系统 选择i3wm作为桌面系统 效果 ","date":"2020-10-10T22:33:37+08:00","image":"https://c-poet.github.io/post/linux/ubuntu-install-i3wm/20201010210117359_hu08752ba7ad548d0fa198580f976d04bc_194879_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/linux/ubuntu-install-i3wm/","title":"Ubuntu安装i3wm（i3窗口管理器）"},{"content":"在vue项目的配置文件vue.config.js的配置文件中添加publicPath配置\n1 2 3 4 5 module.exports = { ... publicPath: \u0026#39;\u0026#39; ... } 如果没有vue.config.js文件，可以手动创建。\n已安装vue cli脚手架的情况下，可以在vue ui中进行配置。\n启动vue ui 1 2 # 在终端执行 vue ui 配置publicPath 把Public Path设置为空。\n","date":"2020-10-08T22:41:20+08:00","image":"https://c-poet.github.io/post/framework/vue/vue-config-public-path/20201008000732349_hua0d4fa7982ccb3e076a0cbba4dbea151_24980_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/framework/vue/vue-config-public-path/","title":"Vue配置使用相对路径访问静态资源（js、css、images）"},{"content":" 在GRUD启动选择界面按下e键进入启动项编辑界面 在linux16这一行的后面加上rd.break，在按下Ctrl + x(或 F10)的组合键以进入Linux的紧急救援模式 在紧急救援模式下执行下列的命令完成密码重置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 以读写的方式重新挂载sysroot mount -o remount,rw /sysroot # 切换至sysroot chroot /sysroot # 密码重置 # 格式： echo 密码|passwd 用户名 --stdin echo 123456|passwd root --stdin # 使配置生效 touch /.autorelabel # 退出sysroot并重启 exit reboot 重启后即可使用新密码进行登录\n","date":"2020-10-06T23:05:30+08:00","image":"https://c-poet.github.io/post/linux/centos-reset-root-password/20201006224245486_hu25f0f61b8e21cc07146e9bd5cd0cc32e_11165_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/linux/centos-reset-root-password/","title":"Linux忘记密码解决方案-紧急救援模式密码重置"},{"content":"Hibernate架构 Hibernate架构图：\nHibernate 使用不同的现存 Java API，比如 JDBC，Java 事务 API（JTA），以及 Java 命名和目录界面（JNDI）。JDBC 提供了一个基本的抽象级别的通用关系数据库的功能， Hibernate 支持几乎所有带有 JDBC 驱动的数据库。JNDI 和 JTA 允许 Hibernate 与 J2EE 应用程序服务器相集成。\n配置对象 配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。\n数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。 类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。 SessionFactory对象 配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。\n数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。 类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。 Session对象 配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。\n数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。 类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。 Transaction对象 配置对象是你在任何 Hibernate 应用程序中创造的第一个 Hibernate 对象，并且经常只在应用程序初始化期间创造。它代表了 Hibernate 所需一个配置或属性文件。配置对象提供了两种基础组件。\n数据库连接：由 Hibernate 支持的一个或多个配置文件处理。这些文件是 hibernate.properties 和 hibernate.cfg.xml。 类映射设置：这个组件创造了 Java 类和数据库表格之间的联系。 Query对象 Query 对象使用 SQL 或者 Hibernate 查询语言（HQL）字符串在数据库中来检索数据并创造对象。一个查询的实例被用于连结查询参数，限制由查询返回的结果数量，并最终执行查询。\nCriteria Criteria 对象被用于创造和执行面向规则查询的对象来检索对象。可以利用该类来完成非sql语句的数据过滤查询。\n引入Hibernate 手动引入 在Hibernate官网http://hibernate.org/orm/releases/下载合适版本的资料，其中包括hibernate的源码、编译好的jar包和文档信息。\n对于普通使用只需要把lib\\required目录下的jar包引入项目，对于缓存的使用，需要引入lib\\optional\\ehcache目录下的EHCache的jar包。\nmaven hibernate包\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.21.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 缓存Ehcache\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.21.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Hibernate6目前还处于测试版。\n使用之前还需要引入对应自己DataBase的JDBC驱动。\nhibernate.cfg.xml配置文件 hibernate.cfg.xml是hibernate配置文件的默认文件名，只需要将hibernate.cfg.xml文件放在项目目录下，hibernate将自动读取文件中的配置。(对于普通的java项目，hibernate.cfg.xml应该放在src目录下)\n通常需要配置SQL方言、连接驱动、数据库url地址、用户名和密码等。可以使用mapping标签来指示映射文件路径，可以同hibernate的配置文件放在项目根目录下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration SYSTEM \u0026#34;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\u0026#34;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;!-- 配置一个session工厂--\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- sql方言--\u0026gt; \u0026lt;property name=\u0026#34;hibernate.dialect\u0026#34;\u0026gt; org.hibernate.dialect.MySQLDialect \u0026lt;/property\u0026gt; \u0026lt;!-- jdbc驱动--\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.driver_class\u0026#34;\u0026gt; com.mysql.cj.jdbc.Driver \u0026lt;/property\u0026gt; \u0026lt;!-- 数据库链接--\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.url\u0026#34;\u0026gt; jdbc:mysql://localhost:3306/hibernate_study?serverTimezone=UTC \u0026lt;/property\u0026gt; \u0026lt;!-- 用户名--\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.username\u0026#34;\u0026gt; dev \u0026lt;/property\u0026gt; \u0026lt;!-- 密码--\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.password\u0026#34;\u0026gt; 123456 \u0026lt;/property\u0026gt; \u0026lt;!-- 映射文件--\u0026gt; \u0026lt;!-- 支持package、class、file、jar --\u0026gt; \u0026lt;mapping resource=\u0026#34;User.hbm.xml\u0026#34; /\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt; 几个重要的配置属性 NO 属性和描述 1 hibernate.connection.datasource 在应用程序服务器环境中您正在使用的应用程序 JNDI 名。 2 hibernate.jndi.class JNDI 的 InitialContext 类。 3 hibernate.jndi. 在 JNDI的 InitialContext 类中通过任何你想要的 Java 命名和目录接口属性。 4 hibernate.jndi.url 为 JNDI 提供 URL。 5 hibernate.connection.username 数据库用户名。 6 hibernate.connection.password 数据库密码。 数据库方言 数据库 方言属性 DB2 org.hibernate.dialect.DB2Dialect HSQLDB org.hibernate.dialect.HSQLDialect HypersonicSQL org.hibernate.dialect.HSQLDialect Informix org.hibernate.dialect.InformixDialect Ingres org.hibernate.dialect.IngresDialect Interbase org.hibernate.dialect.InterbaseDialect Microsoft SQL Server 2000 org.hibernate.dialect.SQLServerDialect Microsoft SQL Server 2005 org.hibernate.dialect.SQLServer2005Dialect Microsoft SQL Server 2008 org.hibernate.dialect.SQLServer2008Dialect MySQL org.hibernate.dialect.MySQLDialect Oracle (any version) org.hibernate.dialect.OracleDialect Oracle 11g org.hibernate.dialect.Oracle10gDialect Oracle 10g org.hibernate.dialect.Oracle10gDialect Oracle 9i org.hibernate.dialect.Oracle9iDialect PostgreSQL org.hibernate.dialect.PostgreSQLDialect Progress org.hibernate.dialect.ProgressDialect SAP DB org.hibernate.dialect.SAPDBDialect Sybase org.hibernate.dialect.SybaseDialect Sybase Anywhere org.hibernate.dialect.SybaseAnywhereDialec 简单的XML映射文件 所有的Entity应该是按照java bean的要求编写的POJO对象，以User Entity为例。\nUser Entity:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package cn.llzero.entity; import java.io.Serializable; public class User implements Serializable { private Integer id; private String name; private String pass; private Character sex; public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public String getName() { return name; } public User setName(String name) { this.name = name; return this; } public String getPass() { return pass; } public User setPass(String pass) { this.pass = pass; return this; } public Character getSex() { return sex; } public User setSex(Character sex) { this.sex = sex; return this; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, pass=\u0026#39;\u0026#34; + pass + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, sex=\u0026#34; + sex + \u0026#39;}\u0026#39;; } } XML映射文件（User.hbm.xml）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE hibernate-mapping PUBLIC \u0026#34;-//Hibernate/Hibernate Mapping DTD//EN\u0026#34; \u0026#34;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\u0026#34;\u0026gt; \u0026lt;hibernate-mapping\u0026gt; \u0026lt;class name=\u0026#34;cn.llzero.entity.User\u0026#34; table=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;meta attribute=\u0026#34;description\u0026#34;\u0026gt; User映射，学习Hibernate \u0026lt;/meta\u0026gt; \u0026lt;id name=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34; type=\u0026#34;integer\u0026#34; \u0026gt; \u0026lt;generator class=\u0026#34;native\u0026#34; /\u0026gt; \u0026lt;/id\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34; unique=\u0026#34;true\u0026#34; type=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;pass\u0026#34; column=\u0026#34;pass\u0026#34; type=\u0026#34;string\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34; type=\u0026#34;char\u0026#34;/\u0026gt; \u0026lt;/class\u0026gt; \u0026lt;/hibernate-mapping\u0026gt; name =\u0026gt; 对应实体的属性， column =\u0026gt; 数据库字段， type指示了数据的类型，该属性建议使用hibernate的预设值。\nhibernate type预设值 当你准备一个 Hibernate 映射文件时，我们已经看到你把 Java 数据类型映射到了 RDBMS 数据格式。在映射文件中已经声明被使用的 types 不是 Java 数据类型；它们也不是 SQL 数据库类型。这种类型被称为 Hibernate 映射类型，可以从 Java 翻译成 SQL，反之亦然。\n在这一章中列举出所有的基础，日期和时间，大型数据对象，和其它内嵌的映射数据类型。\n原始类型 映射类型 Java 类型 ANSI SQL 类型 integer int 或 java.lang.Integer INTEGER long long 或 java.lang.Long BIGINT short short 或 java.lang.Short SMALLINT float float 或 java.lang.Float FLOAT double double 或 java.lang.Double DOUBLE big_decimal java.math.BigDecimal NUMERIC character java.lang.String CHAR(1) string java.lang.String VARCHAR byte byte 或 java.lang.Byte TINYINT boolean boolean 或 java.lang.Boolean BIT yes/no boolean 或 java.lang.Boolean CHAR(1) (\u0026lsquo;Y\u0026rsquo; or \u0026lsquo;N\u0026rsquo;) true/false boolean 或 java.lang.Boolean CHAR(1) (\u0026lsquo;T\u0026rsquo; or \u0026lsquo;F\u0026rsquo;) 日期和时间类型 映射类型 Java 类型 ANSI SQL 类型 date java.util.Date 或 java.sql.Date DATE time java.util.Date 或 java.sql.Time TIME timestamp java.util.Date 或 java.sql.Timestamp TIMESTAMP calendar java.util.Calendar TIMESTAMP calendar_date java.util.Calendar DATE 二进制和大型数据类型 映射类型 Java 类型 ANSI SQL 类型 binary byte[] VARBINARY (or BLOB) text java.lang.String CLOB serializable any Java class that implements java.io.Serializable VARBINARY (or BLOB) clob java.sql.Clob CLOB blob java.sql.Blob BLOB JDK相关类型 映射类型 Java 类型 ANSI SQL 类型 class java.lang.Class VARCHAR locale java.util.Locale VARCHAR timezone java.util.TimeZone VARCHAR currency java.util.Currency VARCHAR 对应的sql：\n1 2 3 4 5 6 7 8 create table user ( id int auto_increment primary key, name varchar(20) not null, pass varchar(30) not null, sex char default \u0026#39;M\u0026#39; not null, constraint name unique (name) )charset = utf8; 映射注解 使用hibernate的注解比使用xml映射文件的方式方便，而且具有良好的可观性。特别是在spring推崇的去文档化，尽量减少对xml这类文档的依赖，采用编程的方式解决配置等问题。\n@Entity @Entity用于对POJO实体类注解，以明确这是一个实体类。\n1 2 3 4 @Entity public class User implements Serializable { ... } @Table @Table用于注解实体对应的表。\n1 2 3 4 5 @Entity @Table(name = \u0026#34;user\u0026#34;) public class User implements Serializable { ... } @Id @Id用于对primark key主键属性的注解。\n1 2 3 4 5 6 7 @Entity @Table(name = \u0026#34;user\u0026#34;) public class User implements Serializable { @Id private Integer id; ... } @GeneratedValue @GeneratedValue注解指示了属性值的生成策略，通常选用GenerationType.AUTO即可。\n1 2 3 4 5 6 7 @Entity @Table(name = \u0026#34;user\u0026#34;) public class User implements Serializable { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; ... } GenerationType.AUTO : 自动选择\nGenerationType.SEQUENCE : 按顺序自增\nGenerationType.Table : 按值表的方式，由hibernate生成一个主键表\nGenerationType.IDENTITY : 保持与entity一致\n@Column @Column注解用于映射实体的属性和表的字段的关系。\n1 2 3 4 5 6 7 8 9 10 11 @Entity @Table(name = \u0026#34;user\u0026#34;) public class User implements Serializable { @Id @GeneratedValue(strategy = GenerationType.AUTO) @Column(name = \u0026#34;id\u0026#34;) private Integer id; @Column(name = \u0026#34;name\u0026#34;, nullable = false, unique = true) private String name; ... } @DynamicUpdate和@DynamicInsert 指示在对象的更新与插入时，过滤null值的属性。\n1 2 3 4 5 6 7 @Entity @Table(name = \u0026#34;user\u0026#34;) @DynamicUpdate @DynamicInsert public class User implements Serializable { ... } 实体关系（表间关系） 对于关系模式的表间关系有一对一、一对多、多对多的关系，可以通过注解的方式来完成实体间的关系。\n注意：在完成对象关系时，有关系“提供方”和“使用方”。关系的提供方要维护两者关系，负责对数据的操作。\n对于一对一和多对多，维护方按照实际对象关系确定即可，对于一对多的方式，维护方只能为一的那个对象。\n@OneToOne (一对一) 现在有User和Role两个类，假设一个用户只能有一个角色，一个角色只能属于一个用户。\n对于User类：\n1 2 3 4 5 6 7 8 9 10 11 @Entity @Table(name = \u0026#34;user\u0026#34;) @DynamicUpdate @DynamicInsert public class User implements Serializable { ... @OneToOne @JoinColumn(name = \u0026#34;role_id\u0026#34;, referencedColumnName = \u0026#34;id\u0026#34;, nullable = false) private Role role; ... } 对于Role类：\n1 2 3 4 5 6 7 8 9 10 @Entity @Table(name = \u0026#34;role\u0026#34;) @DynamicInsert @DynamicUpdate public class Role implements Serializable { ... @OneToOne(mappedBy = \u0026#34;role\u0026#34;) private User user; ... } @OneToMany (一对多) 假设一个用户有多个角色，一个角色只能属于一个用户。\n对于User类：\n1 2 3 4 5 6 7 8 9 10 @Entity @Table(name = \u0026#34;user\u0026#34;) @DynamicUpdate @DynamicInsert public class User implements Serializable { ... @OneToMany(mappedBy = \u0026#34;user\u0026#34;) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); ... } 对于Role类：\n1 2 3 4 5 6 7 8 9 10 11 @Entity @Table(name = \u0026#34;role\u0026#34;) @DynamicInsert @DynamicUpdate public class Role implements Serializable { ... @ManyToOne @JoinColumn(name = \u0026#34;user_id\u0026#34;, referencedColumnName = \u0026#34;id\u0026#34;, nullable = false) private User user; ... } @ManyToMany (多对多) 假设一个用户可以有多个角色 ，一个角色可以属于多个用户。（注意：多对多的情况需要准备中间表。）\n根据实际分析，由User来作关系的维护者。\n对于User类:\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Entity @Table(name = \u0026#34;user\u0026#34;) @DynamicUpdate @DynamicInsert public class User implements Serializable { ... // @JoinColumns定义了中间表的信息 @ManyToMany(targetEntity = Role.class) @JoinTable(name = \u0026#34;user_role\u0026#34;, joinColumns = {@JoinColumn(name = \u0026#34;user_id\u0026#34;, referencedColumnName = \u0026#34;id\u0026#34;, nullable = false)} , inverseJoinColumns = {@JoinColumn(name = \u0026#34;role_id\u0026#34;, referencedColumnName = \u0026#34;id\u0026#34;, nullable = false)}) private Set\u0026lt;Role\u0026gt; roles = new HashSet\u0026lt;\u0026gt;(); ... } 对于Role类:\n1 2 3 4 5 6 7 8 9 10 @Entity @Table(name = \u0026#34;role\u0026#34;) @DynamicInsert @DynamicUpdate public class Role implements Serializable { ... @ManyToMany(mappedBy = \u0026#34;roles\u0026#34;) private Set\u0026lt;User\u0026gt; users = new HashSet\u0026lt;\u0026gt;(); ... } 创建会话（Session） 创建会话首先需要SessionFactory，可以通过Configuration读取hibernate的配置文件，或者通过setProperty的方式设定hibernate的属性。\nSessionFactory 读取项目目录下的默认配置文件(hibernate.cfg.xml)\n1 2 // 以下语句将使用默认的hibernate.cfg.xml配置文件 private final static SessionFactory FACOTRY = new Configuration().configure().buildSessionFactory(); 指定配置文件\n1 2 3 4 5 6 7 // 指定配置文件，只需要在invoke configure方法时传入配置文件信息 // configure方法原型如下： configure();\t// 读取hibernate.cfg.xml // 以下自定义配置文件名 configure(String resource); configure(URL url); configure(File configFile); 通过编程方式设定 setProperty方法：\n1 2 3 4 5 6 7 // 一个简单的例子如下： new Configuration().configure() .setProperty(\u0026#34;hibernate.dialect\u0026#34;, \u0026#34;org.hibernate.dialect.MySQLDialect\u0026#34;) .setProperty(\u0026#34;hibernate.connection.driver_class\u0026#34;, \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;) .setProperty(\u0026#34;hibernate.connection.url\u0026#34;, \u0026#34;jdbc:mysql://localhost:3306/hibernate_study?serverTimezone=UTC\u0026#34;) .setProperty(\u0026#34;hibernate.connection.username\u0026#34;, \u0026#34;dev\u0026#34;).setProperty(\u0026#34;hibernate.connection.password\u0026#34;, \u0026#34;123456\u0026#34;) .buildSessionFactory(); setProperties方法：\n1 2 3 4 5 6 7 // 实例化Properties对象 Properties prs = new Properties(); prs.put(\u0026#34;hibernate.dialect\u0026#34;, \u0026#34;org.hibernate.dialect.MysqlDialect\u0026#34;); prs.put(\u0026#34;hibernate.connection.driver_class\u0026#34;, \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); ... // 设置配置 new Configuration().configure().setProperties(prs); 打开会话 当获得SeesionFactory后，就可以通过factory来开启Session会话。\n1 2 3 4 5 6 7 8 9 // 开户一个会话 Session session = FACTORY.openSession(); coding... // 使用完成后关闭会话 session.close(); // 也可以通过factory关闭所有已打开的会话，这是不安全的 //FACTORY.close(); HQL (hibernate query language) HQL的语法和T-SQL的语法大致相同，不过HQL是对对象进行操作（对象已经和相应的表进行映射 ），而T-SQL直接针对的是表。使用HQL的INSERT语句时需要注意，INSERT语句不允许直接插入新的对象数据，但是可以将一个对象的信息插入另一个对象（与SELECT语句结合使用）。\nSELECT语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 如果要查询某个对象的所有属性，可以省略SELECT // 注意这里的User是实体，而不是表名 String hql = \u0026#34;FROM User\u0026#34;;\t// 等效于 \u0026#34;SELECT * FROM User\u0026#34; // 创建查询 session.createQuery(hql);\t// =\u0026gt; 返回Query对象 // 可以将User.class传入 session.createQuery(hql, User.class);\t// =\u0026gt; 返回Query\u0026lt;User\u0026gt;对象 // 最后可以通过list()方法来获取结果集 session.createQuery(hql, User.class).list();\t// getResultsList()调用的是list()方法 // 只需要获取一个结果，可以使用getSingleResult()方法，直接返回一个User对象 session.createQuery(hql, User.class).getSingleResult(); 查询单个属性或者多个属性时，必要的时候需要将结果存入map中，方便对数据进行读取。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 只查询id属性 String hql = \u0026#34;SELECT id FROM User\u0026#34;; Query query = Session.createQuery(hql); // 获取结果集 List list = query.list();\t// 返回的是含有属性值的列表 // 可以转换为map List list1 = query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP).list(); // 返回含有map的list列表 // 对于多个属性的查询，以上的转换是非常必要的，否则只能得到Object对象 // 注意：hibernate的很多方法已经弃用，包括setResultTransformer方法。 // 实际上对于简单的CRUD，可以通过hibernate封装的find、save、saveOrUpdate、delete方法来操作实体。 String hql = \u0026#34;SELECT id, name FROM User\u0026#34;; Query query1 = session.createQuery(hql); List list2 = query1.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP).list(); 动态参数 曾几何时，使用jdbc的时候，使用\u0026quot;?\u0026ldquo;作为占位符。现在使用hibernate绑定参数变得更加方便，可以使用\u0026rdquo;:\u0026ldquo;的方式，或者使用jpa的占位格式，\u0026rdquo;?\u0026quot;。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 绑定参数 String hql = \u0026#34;UPDATE User Set name = :name, pass = :pass WHERE id = :id\u0026#34;; // 对于非查询操作，记得开启事务 Transaction tx = sexxion.beginTransaction(); Query query = session.createQuery(hql, User.class); query.setParameter(\u0026#34;name\u0026#34;, \u0026#34;newName\u0026#34;); query.setParameter(\u0026#34;pass\u0026#34;, \u0026#34;newPass\u0026#34;); query.setParameter(\u0026#34;id\u0026#34;, 1); System.out.println(query.executeUpdate()); // 提交当前事务 tx.commit(); // 使用jpa的占位符格式 // jpa的格式的问号加上参数索引的方式 // 即 \u0026#34;?\u0026lt;parameter-index\u0026gt;\u0026#34; // 注意：索引下标是从0开始的 String hql = \u0026#34;FROM User WHERE id = ?0\u0026#34;; Query query = session.createQuery(hql, User.class); query.setParameter(0, 1);\t// fistr param is index System.out.println(query.list()); DELETE语句 在实际的测试中，对于非查询的语句需要开启事务，否则将会出现异常。其次与查询不同的是需要调用executeUpdate()方法来执行非查询操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 String hql = \u0026#34;DELETE FROM User WHERE id = 1\u0026#34;; // 开启事务 Transaction tx = session.beginTransaction(); try { // 执行delete int res = session.createQuery(hql).executeUpdate(); // 提交事务 tx.commit(); }catch (HibernateException e) { e.printStackTrace(); tx.rollback(); // 回滚 }finally { // 关闭session session.close(); } return -1; UPDATE语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String hql = \u0026#34;UPDATE User SET name = \u0026#39;llzero\u0026#39;, pass = \u0026#39;123456\u0026#39; WHERE id = 1\u0026#34;; // 开启事务 Transaction tx = session.beginTransaction(); try { int res = session.createQuery(hql).executeUpdate(); // 提交事务 tx.commit(); }catch (HibernateException e) { e.printStackTrace(); tx.rollback(); // 回滚 }finally { // 关闭session session.close(); } return -1; INSERT语句 1 2 3 4 5 // 注意：INSERT不能用于直接插入对象，只有用于复制对象 // 不像T-SQL一样，有VALUES关键字 // 复制id为1的对象的pass和sex属性，并产生一个name为\u0026#39;llZero\u0026#39;的新对象 String hql = \u0026#34;INSERT INTO User(name, pass, sex) SELECT \u0026#39;llZero\u0026#39;, pass, sex FROM User WHERE id = 1\u0026#34;; ... WHERE 子句 WHERE子句能够对查询的数据进行filter，支持使用AND和OR关键字来组合逻辑，其中表达式符号有\u0026quot;=\u0026quot;、\u0026quot;!=\u0026quot;、\u0026quot;\u0026gt;\u0026quot;、\u0026quot;\u0026gt;=\u0026quot;、\u0026quot;\u0026lt;\u0026quot;、\u0026quot;\u0026lt;=\u0026ldquo;以及\u0026rdquo;()\u0026ldquo;等。\n1 String hql = \u0026#34;FROM User WHERE id = 1 OR id = 3 OR id \u0026gt;= 10\u0026#34;; AS关键字 AS可以为表或者某一属性取别名。\n1 String hql = \u0026#34;SELECT U.id AS uid, U.name AS uname FROM User AS U\u0026#34;; ORDER BY 排序 对于排序，同T-SQL一样，使用ORDER BY关键字，多个参与排序的属性使用“,”隔开。\nDESC : 降序\nASC (默认): 升序\n1 String hql = \u0026#34;FROM User ORDER BY name, id DESC\u0026#34;; GROUP BY 分组 hql的分组同T-SQL一致，多个参与分组的属性采用半角逗号隔开。\n1 String hql = \u0026#34;FROM User GROUP BY name, pass\u0026#34;; 分页查询 hibernate的分页查询通过调用两个方法来实现，其效果和LIMIT关键字相同。\nsetFirstResult(int resultPoint) : 开始读取的位置\nsetMaxResults(int num) : 每次最大多少条数据\n1 2 3 String hql = \u0026#34;FROM User\u0026#34;; // 以下语句从第四个对象开始读取，最多返回5个对象 Query query = session.createQuery(hql, User.class).setFirstResult(3).setMaxRusults(5).list(); 聚合函数 S.N. 方法 描述 1 avg(property name) 属性的平均值 2 count(property name or *) 属性在结果中出现的次数 3 max(property name) 属性值的最大值 4 min(property name) 属性值的最小值 5 sum(property name) 属性值的总和 1 2 // 使用count的例子 String hql = \u0026#34;SELECT count(pass) AS pCount FROM User Group By pass\u0026#34;; 标准查询 hibernate的标查询使用到的Class是Criteria，其实质是将hql进行分拆再组合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 Criteria cr = session.createCriteria(User.class); System.out.println(cr.list()); // 对标准的限制 // 使用add方法来添加对标准的限制 // Restrictions中定义相关限制 cr.add(Restrictions.eq(\u0026#34;id\u0026#34;, 3)); System.out.println(cr.list()); cr.add(Restrictions.isNull(\u0026#34;id\u0026#34;)); cr.add(Restrictions.isNotNull(\u0026#34;id\u0026#34;)); cr.add(Restrictions.isEmpty(\u0026#34;id\u0026#34;); cr.add(Restrictions.isNotEmpty(\u0026#34;id\u0026#34;)); cr.add(Restrictions.ge(\u0026#34;id\u0026#34;, 10)); cr.add(Restrictions.le(\u0026#34;id\u0026#34;, 20)); cr.add(Restrictions.gt(\u0026#34;id\u0026#34;, 30)); cr.add(Restrictions.lt(\u0026#34;id\u0026#34;, 40))); // 模糊查询，使用\u0026#34;%\u0026#34;或\u0026#34;_\u0026#34; cr.add(Restrictions.like(\u0026#34;id\u0026#34;, \u0026#34;5%\u0026#34;)); // 值区间 cr.add(Restrictions.between(\u0026#34;id\u0026#34;, 2, 5)); // AND或OR条件 Criterion cr1 = Restrictions.eq(\u0026#34;id\u0026#34;, 3); Criterion cr2 = Restrictions.eq(\u0026#34;pass\u0026#34;, \u0026#34;123456\u0026#34;); System.out.println(cr.add(Restrictions.and(cr1, cr2)).list()); System.out.println(cr.add(Restrictions.or(cr1, cr2)).list()); // 分页 System.out.println(cr.setFirstResult(2).setMaxResults(2).list()); // 排序，使用Order类 // 注意addOrder方法 System.out.println(cr.addOrder(Order.desc(\u0026#34;id\u0026#34;)).list()); // 预测与聚合 // Projections类中的方法有求最值、平均值等的方法 System.out.println(cr.setProjection(Projections.avg(\u0026#34;id\u0026#34;))); System.out.println(cr.setProjection(Projections.max(\u0026#34;id\u0026#34;)).list()); 原生查询 hibernate除了支持HQL与标准查询以外，同样也可以使用原生的SQL语句进行查询。但是并不建议那么做，因为不同的DBMS的语法存在出入，可能会为移植带来不便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 String sql = \u0026#34;SELECT * FROM user\u0026#34;; NativeQuery sqlQuery = session.createSQLQuery(sql); System.out.println(sqlQuery.list()); // 标量查询 String sql = \u0026#34;SELECT id,name FROM user\u0026#34;; NativeQuery sqlQuery = session.createSQLQuery(sql); // 把结果转换为map对象 Query query = sqlQuery.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP); System.out.println(query.list()); // 实体查询 // 通过SqlQuery的addEntity(O)方法添加实体映射数据 String sql = \u0026#34;SELECT * FROM user\u0026#34;; SQLQuery sqlQuery = session.createSQLQuery(sql); // 绑定的实体 sqlQuery.addEntity(\u0026#34;cn.llzero.entity.User\u0026#34;); sqlQuery.addEntity(User.class); System.out.println(sqlQuery.list()); // 动态参数 // 可以参考HQL String sql = \u0026#34;SELECT * FROM user WHERE id = :id\u0026#34;; SQLQuery sqlQuery = session.createSQLQuery(sql); sqlQuery.addEntity(\u0026#34;cn.llzero.entity.User\u0026#34;); sqlQuery.setParameter(\u0026#34;id\u0026#34;, 3); System.out.println(sqlQuery.getSingleResult()); interceptor 拦截器 实现hibernate的拦截器有两种方式，一种是实现Interceptor接口，还有一种就是继承EmptyInterceptor空拦截器选择性的重写自己想要实现的方法。\nInterceptor的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public interface Interceptor { boolean onLoad(Object var1, Serializable var2, Object[] var3, String[] var4, Type[] var5) throws CallbackException; boolean onFlushDirty(Object var1, Serializable var2, Object[] var3, Object[] var4, String[] var5, Type[] var6) throws CallbackException; boolean onSave(Object var1, Serializable var2, Object[] var3, String[] var4, Type[] var5) throws CallbackException; void onDelete(Object var1, Serializable var2, Object[] var3, String[] var4, Type[] var5) throws CallbackException; void onCollectionRecreate(Object var1, Serializable var2) throws CallbackException; void onCollectionRemove(Object var1, Serializable var2) throws CallbackException; void onCollectionUpdate(Object var1, Serializable var2) throws CallbackException; void preFlush(Iterator var1) throws CallbackException; void postFlush(Iterator var1) throws CallbackException; Boolean isTransient(Object var1); int[] findDirty(Object var1, Serializable var2, Object[] var3, Object[] var4, String[] var5, Type[] var6); Object instantiate(String var1, EntityMode var2, Serializable var3) throws CallbackException; String getEntityName(Object var1) throws CallbackException; Object getEntity(String var1, Serializable var2) throws CallbackException; void afterTransactionBegin(Transaction var1); void beforeTransactionCompletion(Transaction var1); void afterTransactionCompletion(Transaction var1); /** @deprecated */ @Deprecated String onPrepareStatement(String var1); } 编写HibernateInterceptor类，并继承EmptyInterceptor重写方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 public class HibernateInterceptor extends EmptyInterceptor { @Override public void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) { System.out.println(\u0026#34;on delete!\u0026#34;); super.onDelete(entity, id, state, propertyNames, types); } @Override public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) { System.out.println(\u0026#34;on flush dirty\u0026#34;); return super.onFlushDirty(entity, id, currentState, previousState, propertyNames, types); } @Override public boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) { System.out.println(\u0026#34;on load\u0026#34;); return super.onLoad(entity, id, state, propertyNames, types); } @Override public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types) { System.out.println(\u0026#34;on save\u0026#34;); return super.onSave(entity, id, state, propertyNames, types); } @Override public void postFlush(Iterator entities) { System.out.println(\u0026#34;post flush\u0026#34;); super.postFlush(entities); } @Override public void preFlush(Iterator entities) { System.out.println(\u0026#34;pre flush\u0026#34;); super.preFlush(entities); } @Override public Boolean isTransient(Object entity) { System.out.println(\u0026#34;isTransient\u0026#34;); return super.isTransient(entity); } @Override public Object instantiate(String entityName, EntityMode entityMode, Serializable id) { System.out.println(\u0026#34;instantiate\u0026#34;); return super.instantiate(entityName, entityMode, id); } @Override public int[] findDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) { System.out.println(\u0026#34;findDirty\u0026#34;); return super.findDirty(entity, id, currentState, previousState, propertyNames, types); } @Override public String getEntityName(Object object) { System.out.println(\u0026#34;getEntityName\u0026#34;); return super.getEntityName(object); } @Override public Object getEntity(String entityName, Serializable id) { System.out.println(\u0026#34;getEntity\u0026#34;); return super.getEntity(entityName, id); } @Override public void afterTransactionBegin(Transaction tx) { System.out.println(\u0026#34;afterTransactionBegin\u0026#34;); super.afterTransactionBegin(tx); } @Override public void afterTransactionCompletion(Transaction tx) { System.out.println(\u0026#34;afterTransactionCompletion\u0026#34;); super.afterTransactionCompletion(tx); } @Override public void beforeTransactionCompletion(Transaction tx) { System.out.println(\u0026#34;beforeTransactionCompletion\u0026#34;); super.beforeTransactionCompletion(tx); } @Override public String onPrepareStatement(String sql) { System.out.println(\u0026#34;onPrepareStatement\u0026#34;); return super.onPrepareStatement(sql); } @Override public void onCollectionRemove(Object collection, Serializable key) throws CallbackException { System.out.println(\u0026#34;onCollectionRemove\u0026#34;); super.onCollectionRemove(collection, key); } @Override public void onCollectionRecreate(Object collection, Serializable key) throws CallbackException { System.out.println(\u0026#34;onCollectionRecreate\u0026#34;); super.onCollectionRecreate(collection, key); } @Override public void onCollectionUpdate(Object collection, Serializable key) throws CallbackException { System.out.println(\u0026#34;onCollectionUpdate\u0026#34;); super.onCollectionUpdate(collection, key); } } 拦截器常用方法解释 findDirty() 这个方法在当 flush() 方法在一个 Session 对象上被调用时被调用。 instantiate() 这个方法在一个持续的类被实例化时被调用。 isUnsaved() 这个方法在当一个对象被传到 saveOrUpdate() 方法时被调用。 onDelete() 这个方法在一个对象被删除前被调用。 onFlushDirty() 这个方法在当 Hibernate 探测到一个对象在一次 flush（例如，更新操作）中是脏的（例如，被修改）时被调用。 onLoad() 这个方法在一个对象被初始化之前被调用。 onSave() 这个方法在一个对象被保存前被调用。 postFlush() 这个方法在一次 flush 已经发生并且一个对象已经在内存中被更新后被调用。 preFlush() 这个方法在一次 flush 前被调用。\n使用自定义拦截器 1 2 3 4 5 // 对于所有的会话 // 通过setInterceptor方法指定拦截器 private final static SessionFactory FACTORY = new Configuration().configure() .setInterceptor(new HibernateInterceptor()).addAnnotatedClass(User.class) .buildSessionFactory(); hibernate缓存 使用 session.flush() 和 session.clear() 可以同步缓存和清理内存中的缓存，hibernate默认使用的CacheProvider是EHCache。\n","date":"2020-10-06T22:50:48+08:00","permalink":"https://c-poet.github.io/post/framework/spring/hibernate-orm-basic/","title":"Hibernate入门篇 - ORM真香"},{"content":"编译环境 系统：Ubuntu18.04 QT版本：Qt 5.14.0 gcc版本：gcc version 7.5.0 qt官方编译驱动方式 在使用QT连接数据库时遇见的第一个错误就是QMYSQL driver not loaded，显然这是缺少mysql的驱动。我们需要手动编译mysql的驱动，qt官方给出的编译教程如下：\n细看访问qt网站：https://doc.qt.io/qt-5/sql-driver.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 C:\\Qt5\\5.13.2\\Src\\qtbase\\src\\plugins\\sqldrivers\u0026gt;qmake -version QMake version 3.1 Using Qt version 5.13.2 in C:/Qt5/5.13.2/mingw73_64/lib C:\\Qt5\\5.13.2\\Src\\qtbase\\src\\plugins\\sqldrivers\u0026gt;qmake -- MYSQL_INCDIR=\u0026#34;C:/Program Files/MySQL/MySQL Connector C 6.1/include\u0026#34; MYSQL_LIBDIR=\u0026#34;C:/Program Files/MySQL/MySQL Connector C 6.1/lib\u0026#34; Info: creating stash file C:\\Qt5\\5.13.2\\Src\\qtbase\\src\\plugins\\sqldrivers\\.qmake.stash Running configuration tests... Checking for DB2 (IBM)... no Checking for InterBase... no Checking for MySQL... yes Checking for OCI (Oracle)... no Checking for ODBC... yes Checking for PostgreSQL... no Checking for SQLite (version 2)... no Checking for TDS (Sybase)... no Done running configuration tests. Configure summary: Qt Sql Drivers: DB2 (IBM) .............................. no InterBase .............................. no MySql .................................. yes OCI (Oracle) ........................... no ODBC ................................... yes PostgreSQL ............................. no SQLite2 ................................ no SQLite ................................. yes Using system provided SQLite ......... no TDS (Sybase) ........................... no Qt is now configured for building. Just run \u0026#39;mingw32-make\u0026#39;. Once everything is built, you must run \u0026#39;mingw32-make install\u0026#39;. Qt will be installed into \u0026#39;C:\\Qt5\\5.13.2\\mingw73_64\u0026#39;. Prior to reconfiguration, make sure you remove any leftovers from the previous build. 按照官方的方法，我们需要找到自己mysql头文件和mysql链接库的位置。如果自己的电脑上没有则可以通过mysql网站下载（mariadb和mysql都是使用QMYSQL驱动，因此无论是下载mariadb或者mysql都可以）。如果系统是linux的用户可以通过安装mysql-dev，或者libmariadbclient-dev，不同的linux发行版其包也不同。\nmysql connector下载地址：https://downloads.mysql.com/archives/c-cpp/\n选择对应自己系统版本的包下载，因为我个人不喜欢麻烦，所以我选择ubuntu的x64deb包进行安装。安装以后需要找到头文件和库文件路径。例如我的是：\n1 2 /usr/include/mysql\t# 头文件 /usr/lib/x86_64-linux-gnu/libmysqlcppconn.so.7.8.0.19\t# 库文件 如果不知道确切位置，可以通过find进行搜索。\n1 2 find / mysql 2\u0026gt; /dev/null | grep mysql | grep h find /mysql 2 \u0026gt; /dev/null | grep mysql | grep so 这时候需要把库文件复制到任意能找到的目录，并修改文件名为libmysql.so，也可以通过链接的方式。\n1 2 3 cp /usr/lib/x86_64-linux-gnu/libmysqlcppconn.so.7.8.0.19 /home/yerain/Downloads/libmysql.so # OR ln -s /usr/lib/x86_64-linux-gnu/libmysqlcppconn.so.7.8.0.19 /home/yerain/Downloads/libmysql.so ** 注意：如果安装的是mariadb，和mysql操作相同。**\n接下来就是编译，在终端下切换到qtsql源文件目录下，例如我的是/home/yerain/Tools/Qt5.14.0/5.14.0/Src/qtbase/src/plugins/sqldrivers。在此目录下执行qmake进行编译：\n1 2 3 4 5 qmake -- MYSQL_INCDIR=\u0026#34;/usr/include/mysql\u0026#34; LIBS=\u0026#34;/home/yerain/Downloads/libmysql.so\u0026#34;\t# 注意修改某些参数 # 然后执行 make # 将生成的库文件安装到gcc目录 make install 让人遗憾的是按照官方的方法，我并没有成功编译mysql驱动。按照make的输出来看，我只成功编译了sqlite的驱动。\n不过可能是我的环境问题，而且我引用官方原文教程只是希望多一种可以尝试的方法。\n成功编译的方法 该方法建立在官方教程的基础上，也就是需要将mysql(OR mariadb) connector 的头文件和库文件准备好。修改/home/yerain/Tools/Qt5.14.0/5.14.0/Src/qtbase/src/plugins/sqldrivers/mysql/mysql.pro项目文件（注意更换为自己的qt路径），注释掉QMAKE_USE += mysql。\n1 # QMAKE_USE += mysql 然后添加头文件和库文件路径\n1 2 3 4 INCLUDEPATH += /usr/include/mysql DEPENDPATH += /usr/include/mysql LIBS += /home/yerain/Downloads/libmysql.so # 同样注意更换路径 添加完后在终端(windows 用cmd OR power shell)执行\n1 2 3 qmake # qmake以后执行 make \u0026amp;\u0026amp; make install 编译完成以后即可在/home/yerain/Tools/Qt5.14.0/5.14.0/gcc_64/plugins/sqldrivers中看到增加的libqsqlmysql.so和libqsqlmysql.so.debug文件，这代表已经成功安装qmysql驱动。（如果找不到，可以检查/home/yerain/Tools/Qt5.14.0/5.14.0/Src/qtbase/src/plugins/sqldrivers/plugins/sqldrivers下是否有这两个文件，有的话直接复制到Qt5.14.0/5.14.0/gcc_64/plugins/sqldrivers下即可）。\n测试 测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* QT连接数据库测试 */ qDebug() \u0026lt;\u0026lt; \u0026#34;连接数据库...\u0026#34;; // 连接mysql QSqlDatabase db = QSqlDatabase::addDatabase(\u0026#34;QMYSQL\u0026#34;); db.setHostName(\u0026#34;localhost\u0026#34;); db.setUserName(\u0026#34;root\u0026#34;); db.setPassword(\u0026#34;123456789\u0026#34;); db.setDatabaseName(\u0026#34;qt_test\u0026#34;); if(!db.open()){ qDebug() \u0026lt;\u0026lt; \u0026#34;mysql连接失败！ =\u0026gt; \u0026#34; \u0026lt;\u0026lt; db.lastError().text(); exit(0); // 连接失败退出程序 } qDebug() \u0026lt;\u0026lt; \u0026#34;mysql连接成功！\u0026#34;; QSqlQuery query(db); if(!query.exec(\u0026#34;select * from user\u0026#34;)){ qDebug() \u0026lt;\u0026lt; \u0026#34;查询失败 =\u0026gt; \u0026#34; \u0026lt;\u0026lt; query.lastError(); exit(0); } qDebug() \u0026lt;\u0026lt; \u0026#34;查询成功\u0026#34;; qDebug() \u0026lt;\u0026lt; \u0026#34;-----------------------------------------\u0026#34; \u0026lt;\u0026lt; endl; // qDebug() \u0026lt;\u0026lt; \u0026#34;ID\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\tname\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\tpassword\u0026#34;; while(query.next()){ qDebug() \u0026lt;\u0026lt; query.value(0).toInt() \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; query.value(1).toString() \u0026lt;\u0026lt; \u0026#34;\\t\u0026#34; \u0026lt;\u0026lt; query.value(2).toString(); } qDebug() \u0026lt;\u0026lt; \u0026#34;-----------------------------------------\u0026#34;; qDebug() \u0026lt;\u0026lt; query.lastQuery(); db.close(); 结果：\n结语 如果vim或者没有合适的编辑器的话，可以直接使用QT Create打开.pro项目文件，然后右键编译需要编译的项目即可。\n","date":"2020-02-09T23:14:20+08:00","image":"https://c-poet.github.io/post/framework/qt/qt-build-mysql-driver/_hu2d46c4bca4d385a8737ecab0c9834eff_175664_baf153eb21cf149d8f79d01bf45911d4.png","permalink":"https://c-poet.github.io/post/framework/qt/qt-build-mysql-driver/","title":"QT编译Mysql驱动(Mariadb驱动),解决qmake报错问题"},{"content":" 背景： 鉴于自己前后鼻音和平翘舌不分的缘故，我也是恨下心来使用五笔输入法，在使用的过程中还是有很多问题。其中一个就是在chrome中，五笔输入法不能通过shift（包括其他中英文切换按键）中英文。\n系统版本： Ubuntu18.04 (linux 5.3.0-28-generic)\nchrome版本： Version 79.0.3945.130 (Official Build) (64-bit)\n输入法： IBus 1.5.17 海峰五笔86\n经过测试发现拼音输入法一切正常，无论是IBUS框架还是小企鹅（fcitx）框架，只有五笔输入法在chrome不能正常使用。 目前替代方案就是添加英文输入法，然后通过win + space键切换输入法。\nubuntu系切换输入法快捷键：win + space\n2020年2月1日 记\n","date":"2020-02-01T23:22:50+08:00","permalink":"https://c-poet.github.io/post/linux/ubuntu-chrome-wubi/","title":"Ubuntu下chrome中五笔输入法不能通过shift切换中英文"},{"content":"前言 在开发的过程中，我们都需要用到很多的开发环境，但是在平时开发环境就没有必要运行起来，因此关闭程序的开机启动是很有必要的。前期AS也是在网上搜索了很多关于Linux下关闭程序自启动的方法，但是都失败了。后来在学习Linux的时候，我才知道网上的方法适用于使用system v into启动的Linux，而现在大多数的Linux衍生版已经使用systemd启动。因此在管理程序的时候还是有一定的区别。 下面我就列出两种启动加载下的命令，可根据自己使用Linux的情况使用命令。\nSystemd 启动服务 1 systemctl start servicename.service 关闭服务 1 systemctl stop servicename.service 重启服务 1 systemctl restart sevicename.service 重新加载配置文件 1 systemctl reload sevicename.service 查看服务状态 1 systemctl status revicename.service 开机自启动 1 systemctl enable revicename.service 关闭开机自启动 1 systemctl disable revicename.service System V init 启动服务 1 service servicename start 关闭服务 1 service servicename stop 重启服务 1 service servicename restart 重新加载配置文件 1 service servicename reload 查看服务状态 1 service servicename status 开机自启动 1 chkconfig servicename on 关闭开机自启动 1 chkconfig servicename off END ","date":"2019-03-17T00:02:01+08:00","permalink":"https://c-poet.github.io/post/linux/linux-service-start-command/","title":"最新Linux程序重启、开启关闭开机启动功能"},{"content":"前言 第一次接触tomcat就要增加PHP环境支持，tomcat主要是用来支持JAVAWEB的，在我看来是有一定的难度。但是因为某些需求，还是决定上网搜索相关教程。搜索后发现有这方面需求的人还挺多，教程也挺多。研究了一番，主要分成两种方法：\\1、在服务器上安装PHP环境后，修改web.xml和content.xml文件，完成以后把PHP项目移动到特定的目录中就可以访问PHP项目，（遗憾的是，我配置了几次都没有成功。在访问的时候会被服务器上的JSP项目强制跳转。）。2、方法与第一种类似，在安装PHP环境后，只需要修改web.xml文件，就可以在网站根目录下任意位置访问PHP项目。显然这是一个真正意义上的JAVAWEB+PHP环境。 由于相关教程在网上已经非常详细，我就直接转载到自己的博客中。以便满足以后可能出现的需求。\n第一种配置方法 请移步到http://www.cnblogs.com/cisum/p/7845028.html 阅读 访问成功后，可以把index.php添加到默认入口文件。 添加方法：在conf下的web.xml中找到标签，并在其中加入\u0026lt;FileName.php\u0026gt;。如下 1 2 3 4 5 6 \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.html\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.htm\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;welcome-file\u0026gt;index.php\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; 第二种配置方法 你需要下载PHP环境，并把PHP加入环境变量中。第一种配置方法安装PHP。 配置tomcat支持php项目 下载jar包使tomcat支持php项目 下载地址：链接：https://pan.baidu.com/s/1F77MjMkw9qTHXXRT_IcwtQ 提取码：xcyd 下载以后将其解压，并把jar文件移到tomcat的lib目录下 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-va65egzN-1601773814969)(https://www.orbpi.cn/img/1802/30.jpg)] 接下来就是修改web.xml文件，找到标签，并在其中加入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;php.java.servlet.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;PhpJavaServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;php.java.servlet.PhpJavaServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;PhpCGIServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;php.java.servlet.fastcgi.FastCGIServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;prefer_system_php_exec\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;On\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;php_include_java\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;Off\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;PhpJavaServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.phpjavabridge\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;PhpCGIServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.php\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 然后找到节点，添加以下内容：\n1 \u0026lt;welcome-file\u0026gt;index.php\u0026lt;/welcome-file\u0026gt; 没出意外的话，现在PHP已经配置完成。\n重启tomcat服务\n测试PHP配置是否成功 在tomcat的webapps目录下新建test.php，并在以下加入以下内容：\n1 \u0026lt;?php echo phpinfo(); ?\u0026gt; 如果访问不成功，可以尝试修改访问端口，如80。 END 本文内容参考网上教程，如果疏漏的地方，敬请指正！\n","date":"2018-12-05T00:19:32+08:00","permalink":"https://c-poet.github.io/post/linux/apache-tomcat-php/","title":"在apache-tomcat下配置PHP环境"},{"content":"前言 很多人在做网站的时候可能有这样的需求，前期网站内容不多需要从外站获取，需求量较大的时候，我们不可能手工进行转载。这时候“爬虫”显得尤为重要。下面就让我介绍在php下如何做一个“爬虫”。 前期我在做小程序的时候需要大量的关于电脑的文章（教程），自己打算写一个爬虫直接打算从网上爬取。由于自己的经验不足只单纯的利用了PHP的字符截取替换查找及正则表达式写了一个PHP爬虫，虽然最后达到了爬取的作用，但是因为使用这种方法只能针对具有一样排版的网站（或者说只适用于一个网站），所以当我需要获取其他网站内容时就需要重写算法。这极其不利于后期的维护。后来我想使用PYTHON爬虫获取内容然后入库，然后再用PHP去读，可是这样PYTHON也要和数据对接，这样也不利于维护。之后想到PY作为胶水语言，是不是可以和PHP一起使用呢？虽说可以，但是网上没有确切的解决办法，我也不想花时间去尝试PHP+PYTHON的方法。后面经过查找，找到了PHP中的爬虫类库QUERYLIST。有人可能会有疑问，调用这个类库就能后轻松的爬取内容了吗？我做个简单的比喻，PHP中的QueryList类库就相当于Python中的BS4（Beautiful Soup 4）模块。\nQueryList类库 QueryList虽然可以让我们在PHP环境下轻松的爬取网站内容，但是在功能方面还是不如BS4，如果有特殊需求，建议使用Python BS4。\n官方介绍 我们有时需要抓取一个网页的内容，但只需要特定部分的信息，通常会用正则来解决，这当然没有问题。正则是一个通用解决方案，但特定情况下，往往有更简单快 捷的方法。比如你想查询一个编程方面的问题，当然可以使用Google，但stackoverflow 作为一个专业的编程问答社区，会提供给你更多，更靠谱的答案。\n对于html页面，不应该使用正则的原因主要有3个\n1、编写条件表达式比较麻烦\n尤其对于新手，看到一堆”不知所云”的字符评凑在一起，有种脑袋都要炸了的感觉。如果要分离的对象没有太明显的特征，正则写起来更是麻烦。\n2、效率不高\n对于php来说，正则应该是没有办法的办法，能通过字符串函数解决的，就不要劳烦正则了。用正则去处理一个30多k的文件，效率不敢保证。\n3、有phpQuery\n如果你使用过jQuery，想获取某个特定元素应该是轻而易举的事情，phpQuery让这成为了可能。\nphpQuery 在介绍QueryList之前，有必要先来介绍一下phpQuery。\nphpQuery是一个用php实现的类似jQuery的开源项目，可以在服务器端以jQuery的语法形式解析网页元素。\n基本上jQuery的选择器都可以用在phpQuery上，phpQuery很强大可以对DOM进行任何复杂的操作，而接下来要介绍的QueryList则相当于phpQuery的子集,发挥它采集方面的强大功能。\nQueryList QueryList是一个基于phpQuery的PHP通用列表采集类,得益于phpQuery，让使用QueryList几乎没有任何学习成本，只要会CSS3选择器就可以轻松使用QueryList了，它让PHP做采集像jQuery选择元素一样简单。 QueryList的几个特点:\n学习简单：只有一个核心的API 使用简单：用jQuery选择器来选择页面元素 自带过滤功能，可过滤掉无用的内容 支持无限层级嵌套采集 采集结果直接以采集规则以列表的形式有序的返回 支持扩展\n下载安装使用 下载安装使用，请直接移步官方文档进行查看 官方文档\n框架中使用QueryList 关于框架中使用的方法，官方给出的是THINKPHP3的教程，显然在现在来说THINKPHP3框架太老了，在我写这篇博文的时候THINKPHP框架已经更新到了5.1版本。QueryList官方提供的关于ThinkPHP3的使用方法在5中是不适用的。后期我会把这个补上，写一篇关于ThinkPHP5如何使用类库和QueryList在其中的一些使用技巧。（毕竟我也是刚接触到QueryList类库，需要一段时间的适应期，也希望有大佬可以指点。）\n示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?php require \u0026#39;vendor/autoload.php\u0026#39;; use QL\\QueryList; // 待采集的页面地址 $url = \u0026#39;https://www.cnbeta.com/articles/tech/779841.htm\u0026#39;; // 采集规则 $rules = [ // 文章标题 \u0026#39;title\u0026#39; =\u0026gt; [\u0026#39;.title\u0026gt;h1\u0026#39;,\u0026#39;text\u0026#39;], // 发布日期 \u0026#39;date\u0026#39; =\u0026gt; [\u0026#39;.meta\u0026gt;span:eq(0)\u0026#39;,\u0026#39;text\u0026#39;], // 文章内容 \u0026#39;content\u0026#39; =\u0026gt; [\u0026#39;#artibody\u0026#39;,\u0026#39;html\u0026#39;] ]; $data = QueryList::Query($url,$rules)-\u0026gt;data; print_r($data); 抓取结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Array (Array ( [0] =\u0026gt; Array ( [title] =\u0026gt; GitHub意外宕机 已确认数据存储系统存在问题 [date] =\u0026gt; 2018年10月22日 14:42 [content] =\u0026gt; \u0026lt;p style=\u0026#34;text-align: center;\u0026#34;\u0026gt;\u0026lt;img src=\u0026#34;https://static.cnbetacdn.com/article/2018/1022/82e649adfde2e98.png\u0026#34; alt=\u0026#34;github-down-due-to-data-storage-system-issue-523345-2.png\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;发稿前，GitHub 已经排除了部分故障。目前似乎只有某些特定地区受到了影响，但欧洲等部分地区仍未完全恢复。\u0026lt;/p\u0026gt; \u0026lt;blockquote\u0026gt; \u0026lt;p\u0026gt;GitHub 团队表示，数据存储系统是导致本次故障的罪魁祸首。为尽快恢复服务，他们正在努力修复。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;过去的几个小时，所有工作都集中在这方面。在此期间，部分用户可能看到不一致的结果。\u0026lt;/p\u0026gt; \u0026lt;/blockquote\u0026gt; \u0026lt;p\u0026gt;今年早些时候，\u0026lt;a data-link=\u0026#34;1\u0026#34; href=\u0026#34;https://afflnk.microsoft.com/c/1251234/439031/7808\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;微软\u0026lt;/a\u0026gt;宣布以 75 亿美元收购 GitHub 。近日，欧盟委员会认定微软接管 GitHub 不违背反竞争原则，并准予放行。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;[编译自：\u0026lt;a href=\u0026#34;https://news.softpedia.com/news/github-down-due-to-data-storage-system-issue-523345.shtml\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;Softpedia\u0026lt;/a\u0026gt;]\u0026lt;/p\u0026gt; ) ) END ","date":"2018-11-17T00:16:08+08:00","permalink":"https://c-poet.github.io/post/mixeds/php-querylist/","title":"做PHP爬虫之QUERYLIST库（PHP爬虫插件）"},{"content":" 解决apache服务器不能重定向，不能强制跳转https并且.htaccess失效等问题\napache不能重定向，.htaccess被关闭 在centos系统下一键安装apache服务后，在网站根目录下建立.htaccess文件，想通过.htaccess文件实现apache的重定向。但是发现无论怎么更换.htaccess的代码，都不能重定向。这时候就需要检查.htaccess是否被关闭。\n打开apache的配置文件 1 vim /etc/httpd/conf/httpd.conf 检查配置文件 1 2 3 AllowOverride Node #338行附近 #修改为 AllowOverrlid All #打开.htaccess .htaccess打开后，还是不能访问可以检查文件名称是否正确。\n1 AccessFileName .htaccess #409行附近，检查AccessFileName后面的文件名是否正确，可自定义 修改完成后，需要重启服务器 1 service https restart #重启服务器 实现强制跳转https 要想实现强制跳转https，一般是通过301重定向实现的。针对服务器管理员和网站管理员有以下不同的方法。\n在配置文件中增加跳转代码 1 2 3 4 5 6 7 8 9 10 11 12 #在apache配置文件中增加下面代码 \u0026lt;VirtualHost *:80\u0026gt; ServerAdmin ASorb DocumentRoot /var/www/html/wordpress #网站目录 ServerName www.orbpi.cn #修改为自己的域名 RewriteEngine on RewriteCond %{HTTPS} !=on RewriteRule ^(.*) https://%{SERVER_NAME}$1 [L,R] \u0026lt;/VirtualHost\u0026gt; #添加后需要重启服务器 service httpd restart .htaccess文件实现（使用前请按照上述方法确定.htsccess是否处于打开状态） 在网站根目录下建立.htaccess文件，将下面代码写入.htsccess文件中。( 重要提示：必须将代码放到.htaccess文件内容的最前面，以保证重定向优先权。) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #代码如下： RewriteEngine On RewriteCond %{SERVER_PORT} 80 RewriteRule ^(.*)$ https://www.orbpi.cn/$1 [R,L] #或者 RewriteEngine On RewriteCond %{SERVER_PORT} 80 RewriteRule ^(.*)$ https://www.orbpi.cn/$1 [R=301,L] #又或者 RewriteEngine on RewriteBase / RewriteCond %{SERVER_PORT} !^443$ RewriteRule ^.*$ https://%{SERVER_NAME}%{REQUEST_URI} [L,R] #注意：如果是在子目录，可以用 RewriteEngine On RewriteCond %{SERVER_PORT} 80 RewriteCond %{REQUEST_URI} subfolder RewriteRule ^(.*)$ https://www.orbpi.cn/subfolder [R,L] 效验是否成功跳转 检验是否能够重定向最简单的方法就是通过浏览器的访问，首先在浏览器中访问http://你的网址/，等待响应后，看网址是否变成https://你的网址/，如果发生改变就说明跳转成功，否则失败。有时候不能跳转可能不是服务器的配置问题，有可能是本地浏览器的缓存问题。例如谷歌浏览器就有缓存机制，所以在验证的时候可以先清除缓存在进行效验。\nEND 参考：百度百科\n","date":"2018-11-14T00:12:35+08:00","permalink":"https://c-poet.github.io/post/linux/apache-rewrite-route/","title":"apache不能重定向，不能强制跳转https，-htaccess失效解决办法"},{"content":"说明 前期发得数据结构的算法都是把书上的基本算法和实际问题的算法分离的，现在会把基本算法的头一起发在同一篇博文中，以便查找。（往期的基本算法日志不在更新）。\n问题描述 输入一个由若干单词组成的文本行（最多200个字符），每个单词之间用若干个空格隔开，统计此文本行中单词的个数，并在其中查找任意输入的单词。\n算法 头文件（DataH.h） 注意：这里头文件中的基本算法包含“数据结构C语言版\u0026ndash;严蔚敏”书籍中串的“抽象数据类型ADT”中的基本算法，在实际问题中有的基本算法可能不会被用到。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; /* **数据结构串头文件 **ASorb time:201811 */ //状态码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //函数返回状态码类型 typedef int Status; /**串的堆分配存储表示**/ typedef struct { char *ch; int length; }HString; //生成一个其值等于串常量chars的串T Status StrAssign(HString *T,char *chars){ int len=0; if(T-\u0026gt;ch) free(T-\u0026gt;ch); for(char *c=chars;*c;c++,len++); if(!len){ T-\u0026gt;ch = NULL; T-\u0026gt;length = 0; } else{ if(!(T-\u0026gt;ch=(char*)malloc(sizeof(char)*len))) exit(OVERFLOW); for(int i=0;i\u0026lt;len;i++) T-\u0026gt;ch[i] = chars[i]; T-\u0026gt;length = len; } return OK; } //返回S的元素个数，称为串的长度 int StrLength(HString S){ return S.length; } //串比较 int StrCompare(HString S,HString T){ for(int i=0;i\u0026lt;S.length \u0026amp;\u0026amp; i\u0026lt;T.length;i++) if(S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; return S.length - T.length; } //将S清为空串，并释放S的空间 Status ClearString(HString *S){ if(S-\u0026gt;ch){ free(S-\u0026gt;ch); S-\u0026gt;ch = NULL; } S-\u0026gt;length = 0; return OK; } //用T返回有S1和S2连接而成的新串 Status Concat(HString *T,HString S1,HString S2){ if(T-\u0026gt;ch)free(T-\u0026gt;ch); if(!(T-\u0026gt;ch=(char*)malloc(sizeof(char)*(S1.length+S2.length)))) exit(OVERFLOW); for(int i=0;i\u0026lt;S1.length;i++) T-\u0026gt;ch[i] = S1.ch[i]; for(int i=0;i\u0026lt;S2.length;i++) T-\u0026gt;ch[i+S1.length]=S2.ch[i]; T-\u0026gt;length = S1.length + S2.length; return OK; } //返回串S的第pos个字符起长度为len的子串 Status SubString(HString *Sub,HString S,int pos,int len){ if(pos\u0026lt;1 || pos\u0026gt;S.length || len\u0026lt;0 || len\u0026gt;S.length-pos+1) return ERROR; if(Sub-\u0026gt;ch){ free(Sub-\u0026gt;ch); Sub-\u0026gt;length = 0; } if(!len){ Sub-\u0026gt;ch = NULL; Sub-\u0026gt;length =0; } else{ if(!(Sub-\u0026gt;ch=(char*)malloc(sizeof(char)*len))) exit(OVERFLOW); for(int i=0;i\u0026lt;len;i++) Sub-\u0026gt;ch[i] = S.ch[pos+i-1]; Sub-\u0026gt;length = len; } return OK; } 主函数（main.cpp） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** **实验3 001 **ASorb time:201811 **/ #include\u0026#34;DataH.h\u0026#34; #define MAX_CHARS 200 //返回单词数量 int word_num(HString S) { int num = 0; int is_word = 0; if (S.length == 0)return num; for (int i = 0; i \u0026lt; S.length; i++) { if (S.ch[i] != \u0026#39; \u0026#39;) is_word = 1; if ((S.ch[i] == \u0026#39; \u0026#39;|| i==S.length-1) \u0026amp;\u0026amp; is_word) { num++; is_word = 0; } } return num; } //统计查找单词的数量并记录位置 Status find_word_num(HString S,char chars[],int position[]) { int num = 1; HString T; T.ch = NULL; HString Sub; Sub.ch = NULL; char chars_find[MAX_CHARS]; StrAssign(\u0026amp;T,chars); for (int i = 1; i \u0026lt;= S.length - T.length+1; i++) { SubString(\u0026amp;Sub, S, i, T.length); if (StrCompare(Sub, T) == 0) if ((i == 1 || S.ch[i - 2] == \u0026#39; \u0026#39;) \u0026amp;\u0026amp; (i==S.length-T.length+1||S.ch[i+T.length-1]==\u0026#39; \u0026#39;)) { position[0]++; position[num++] = i; } } ClearString(\u0026amp;Sub); ClearString(\u0026amp;T); return OK; } int main() { HString S;S.ch = NULL; char chars[MAX_CHARS], chars_find[MAX_CHARS]; int position[MAX_CHARS + 1] = { 0 };\t//0位置存储数量，其余存储位置 printf(\u0026#34;输入文本（200字符内）：\u0026#34;); gets_s(chars); StrAssign(\u0026amp;S, chars); printf(\u0026#34;需要查找的单词为：\u0026#34;); gets_s(chars_find); printf(\u0026#34;文段单词数量为：%d\\n\u0026#34;, word_num(S)); find_word_num(S, chars_find, position); printf(\u0026#34;查找单词的数量为:%d\\n\u0026#34;, position[0]); if (position[0]) { printf(\u0026#34;位置记录为：\\n\u0026#34;); for (int i = 1;position[i]; i++) printf(\u0026#34;%4d\u0026#34;, position[i]); } ClearString(\u0026amp;S); getchar(); return 0; } END ","date":"2018-11-14T00:09:17+08:00","permalink":"https://c-poet.github.io/post/coding/c/data-structure-word-count/","title":"数据结构串实现单词统计"},{"content":"说明 具体说明可以参照《数据结构串实现单词统计》中的说明。\n问题描述 一个文本串可用事先给定的字母映射表进行加密。例如，设字母映射表为：\na b c d e f g h i j k l m n o p q r s t u v w x y z\nn g z q t c o b m u h e l k p d a w x f y I v r s j\n则字符串“encrypt”被加密为“tkzwsdf”。\n基本要求：\n① 编写一个算法将输入的文本串进行加密后输出\n② 编写一个算法，将输入的已加密的文本串解密后输出\n③ 编写主函数进行测试\n实现算法 头文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; /* **数据结构串头文件 **ASorb time:201811 */ //状态码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //函数返回状态码类型 typedef int Status; /**串的堆分配存储表示**/ typedef struct { char *ch; int length; }HString; //生成一个其值等于串常量chars的串T Status StrAssign(HString *T,char *chars){ int len=0; if(T-\u0026gt;ch) free(T-\u0026gt;ch); for(char *c=chars;*c;c++,len++); if(!len){ T-\u0026gt;ch = NULL; T-\u0026gt;length = 0; } else{ if(!(T-\u0026gt;ch=(char*)malloc(sizeof(char)*len))) exit(OVERFLOW); for(int i=0;i\u0026lt;len;i++) T-\u0026gt;ch[i] = chars[i]; T-\u0026gt;length = len; } return OK; } //返回S的元素个数，称为串的长度 int StrLength(HString S){ return S.length; } //串比较 int StrCompare(HString S,HString T){ for(int i=0;i\u0026lt;S.length \u0026amp;\u0026amp; i\u0026lt;T.length;i++) if(S.ch[i] != T.ch[i]) return S.ch[i] - T.ch[i]; return S.length - T.length; } //将S清为空串，并释放S的空间 Status ClearString(HString *S){ if(S-\u0026gt;ch){ free(S-\u0026gt;ch); S-\u0026gt;ch = NULL; } S-\u0026gt;length = 0; return OK; } //用T返回有S1和S2连接而成的新串 Status Concat(HString *T,HString S1,HString S2){ if(T-\u0026gt;ch)free(T-\u0026gt;ch); if(!(T-\u0026gt;ch=(char*)malloc(sizeof(char)*(S1.length+S2.length)))) exit(OVERFLOW); for(int i=0;i\u0026lt;S1.length;i++) T-\u0026gt;ch[i] = S1.ch[i]; for(int i=0;i\u0026lt;S2.length;i++) T-\u0026gt;ch[i+S1.length]=S2.ch[i]; T-\u0026gt;length = S1.length + S2.length; return OK; } //返回串S的第pos个字符起长度为len的子串 Status SubString(HString *Sub,HString S,int pos,int len){ if(pos\u0026lt;1 || pos\u0026gt;S.length || len\u0026lt;0 || len\u0026gt;S.length-pos+1) return ERROR; if(Sub-\u0026gt;ch){ free(Sub-\u0026gt;ch); Sub-\u0026gt;length = 0; } if(!len){ Sub-\u0026gt;ch = NULL; Sub-\u0026gt;length =0; } else{ if(!(Sub-\u0026gt;ch=(char*)malloc(sizeof(char)*len))) exit(OVERFLOW); for(int i=0;i\u0026lt;len;i++) Sub-\u0026gt;ch[i] = S.ch[pos+i-1]; Sub-\u0026gt;length = len; } return OK; } 主函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** **实验3 002 **ASorb time:201811 **/ #include\u0026#34;DataH.h\u0026#34; #define MAX_CHARS 100 Status key_op(HString S,char m_chars[],char j_chars[]) { char m_key[] = { \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; };\t//明文 char j_key[] = { \u0026#34;ngzqtcobmuhelkpdawxfyIvrsj\u0026#34; };\t//暗文 for (int i = 0; i \u0026lt; S.length; i++) { for (int ii = 0; ii \u0026lt; 26; ii++) if (S.ch[i] == m_key[ii]) { j_chars[i] = j_key[ii]; break; } else j_chars[i] = S.ch[i]; for (int ii = 0; ii \u0026lt; 26; ii++) if (S.ch[i] == j_key[ii]) { m_chars[i] = m_key[ii]; break; } else m_chars[i] = S.ch[i]; } return OK; } int main() { HString S; S.ch = NULL; char chars[MAX_CHARS], m_chars[MAX_CHARS] = { \u0026#39;\\0\u0026#39; }, j_chars[MAX_CHARS] = { \u0026#39;\\0\u0026#39; }; printf(\u0026#34;输入需要转换的密码：\u0026#34;); gets_s(chars); StrAssign(\u0026amp;S, chars); key_op(S, m_chars, j_chars); ClearString(\u0026amp;S); printf(\u0026#34;你输入的key：%s\\n\u0026#34;,chars); printf(\u0026#34;明文key：%s\\n\u0026#34;, m_chars); printf(\u0026#34;暗文key：%s\\n\u0026#34;, j_chars); getchar(); return 0; } ","date":"2018-11-14T00:05:55+08:00","permalink":"https://c-poet.github.io/post/coding/c/data-structure-encrypt/","title":"数据结构串实现字符串加密"},{"content":"出现的问题 如果说hexo安装了中文链接自动转拼音链接的话，可能会出现分类存在大写字母，那么在URL访问的时候不能访问到该分类的详情页。主要是因为该插件把网页中的url统一改成了小写，而hexo在生成分类的静态网页的时候是按照你填写的英文字母生成相同名的目录。例如：我存在Linux分类，显然在生成分类目录的时候，hexo会对应生成一个Linux的目录。但是在其他网页中，连接到Linux的链接会被插件改成linux。这可能会导致不能访问到Linux。\n解决方法 手动修改生成的目录，把Linux目录统一修改成linux。然后在把服务器上的Linux修改成linux，然后在把本地数据git到服务器即可正常访问。注意的是hexo在生成目录时，会把linux和Linux认定成一个目录，因此以后不需要做第二次修改。\n关闭服务器的大小写区别，关闭以后服务器会自动修正我们访问的url，如访问linux，虽然在网站目录下没有linux目录，但是服务器也会把Linux作为匹配放回给客户端。以apache为例：\n加载mod_speling模块： LoadModule speling_module /usr/lib/apache2/modules/mod_speling.so\n打开httpd.conf配置文件，找到#LoadModule speling_module /usr/lib/apache2/modules/mod_speling.so这一行，去掉前面的#号。 开启模块： CheckSpelling on 在httpd.conf后面加上CheckSpelling on\n重启apache service httpd restart #重启apache服务器\nhexo-permalink-pinyin(中文链接转拼音插件)\n安装 1 npm i hexo-permalink-pinyin --save 开启插件 添加下面内容到配置文件_config.yml\n1 2 3 4 # https://github.com/viko16/hexo-permalink-pinyin permalink_pinyin: enable: true separator: \u0026#39;-\u0026#39; # default: \u0026#39;-\u0026#39; 相关选项 enable:是否启用插件 separator:词自己的间隔符 ​参考：GitHub - viko16/hexo-permalink-pinyin: A Hexo plugin which convert Chinese title to transliterate permalink.\n​\n","date":"2018-10-26T23:52:59+08:00","permalink":"https://c-poet.github.io/post/mixeds/hexo-install-pingyin/","title":"hexo安装链接转拼音出现的问题"},{"content":"​​\n说明 本文主要收录《数据结构（C语言版）》第五版的基本算法，算法包括顺序表，栈，队列等。收录的算法是使用C语言实现的，在调用的时候请注意传参的类型。特别是对指针参数的传入。\n宏\u0026amp;基本算法 宏定义（所有算法必须引入） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 /* **数据结构头文件 **宏定义\u0026amp;基本算法及结构 **asorb\u0026amp;201810 */ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; //状态码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 //函数返回状态码类型 typedef int Status; 线性表\u0026amp;顺序表 /*线性表.顺序表\u0026amp;结构\u0026amp;算法*/ typedef int ElemType; #define LIST_INIT_SIZE 100\t//线性表存储空间的初始分配量 #define LISTINCREMENT 10\t//线性表存储空间的分配增量 typedef struct { ElemType *elem; int length;\t//当前长度 int listsize;\t//当前分配的存储容量（以sizeof(ElemType)为单位） }SqList; Status InitList_Sq(SqList *L){ L-\u0026gt;elem = (ElemType*)malloc(sizeof(ElemType)*LIST_INIT_SIZE); if (!L-\u0026gt;elem) exit(OVERFLOW);\t//空间分配失败 L-\u0026gt;length = 0; L-\u0026gt;listsize = LIST_INIT_SIZE; return OK; }//构造一个空的线性表L Status DestroyList_Sq(SqList *L){ free(L-\u0026gt;elem); if (L-\u0026gt;elem) return ERROR; L-\u0026gt;length = 0; L-\u0026gt;listsize = 0; return OK; }//销毁线性表L Status ClearList_Sq(SqList *L){ L-\u0026gt;length = 0; return OK; }//将L重置为空表 Status ListEmpty_Sq(SqList L){ if (L.length == 0)return TRUE; else return FALSE; }//若L为空表，则返回TRUE,否则返回FALSE int ListLength_Sq(SqList L){ return L.length; }//返回L中的元素个数 Status GetElem_Sq(SqList L,int i, ElemType *e){ if (i\u0026lt;1 || i\u0026gt;L.length)return ERROR; *e = *(L.elem + i - 1); return OK; }//用e返回L中第i个元素的值 int LocateElem_Sq(SqList L, ElemType e, Status compare(ElemType,ElemType)){ int i = 0; while (i \u0026lt; L.length){ if (compare(*(L.elem + i), e)) return i + 1; i++; } return 0; }//返回L中第一个与e满足关系compare()的数据元素的位序。若这样的元素不存在，则返回值为0 Status PriorElem_Sq(SqList L, ElemType cur_e, ElemType *pre_e){ for (int i = 1; i \u0026lt; L.length; i++){ if (*(L.elem + i) == cur_e){ *pre_e = *(L.elem + i - 1); return TRUE; } } return FALSE; }//用pre_e返回cur_e的前驱 Status NextElem_Sq(SqList L, ElemType cur_e, ElemType *next_e){ for (int i = 0; i \u0026lt; L.length - 1; i++){ if (*(L.elem + i) == cur_e){ *next_e = *(L.elem + i + 1); return TRUE; } } return FALSE; }//用next_e返回cur_e的后继 Status ListInsert_Sq(SqList *L, int i, ElemType e){ if (i\u0026lt;1 || i\u0026gt;L-\u0026gt;length + 1)return ERROR; if (L-\u0026gt;length \u0026gt;= L-\u0026gt;listsize){//空间不足，增加空间 L-\u0026gt;elem = (ElemType*)realloc(L-\u0026gt;elem, sizeof(ElemType)*(L-\u0026gt;listsize + LISTINCREMENT)); if (!L-\u0026gt;elem)exit(OVERFLOW);\t//分配失败 L-\u0026gt;listsize += LISTINCREMENT; } for (int ii = L-\u0026gt;length; ii \u0026gt;= i; ii--){//i位以后开始后移 *(L-\u0026gt;elem + ii) = *(L-\u0026gt;elem + ii - 1); } *(L-\u0026gt;elem + i - 1) = e; L-\u0026gt;length++; return OK; }//在L中的第i个位置前插入e，L的长度加1 Status ListDelete_Sq(SqList *L, int i, ElemType *e){ if (i \u0026lt; 1 || i\u0026gt;L-\u0026gt;length)return ERROR; *e = *(L-\u0026gt;elem + i - 1); for (int ii = i - 1; ii \u0026lt; L-\u0026gt;length - 1; ii++){//i位以后前移覆盖 *(L-\u0026gt;elem + ii) = *(L-\u0026gt;elem + ii + 1); } L-\u0026gt;length--; return OK; }//删除L的第i的数据元素，并用e返回其值，L的长度减1 Status ListTraverse_Sq(SqList L, Status visit(ElemType*)){ if (L.length == 0)return ERROR; for (int i = 0; i \u0026lt; L.length; i++) if (!visit(L.elem + i))return ERROR; return OK; }//依次对L中的每个数据元素调用visit() 线性表\u0026amp;链表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 /*线性表.链表\u0026amp;结构\u0026amp;算法*/ typedef struct LNode{ ElemType data; struct LNode *next; }*Link,Position; typedef struct{ Link head, tail;\t//分别指向线性链表中的头结点和最后一个结点 int len;\t//指示线性表元素的个数 }LinkList; Status MakeNode(Link *p, ElemType e){ (*p) = (Link)malloc(sizeof(Position)); if (!(*p))return ERROR; (*p)-\u0026gt;data = e; (*p)-\u0026gt;next = NULL; return OK; }//分配由p指向的值为e的结点，并返回OK，否则返回ERROR void FreeNode(Link p){ free(p); }//释放p所指的结点 Status InitList_L(LinkList *L){ L-\u0026gt;head = (Link)malloc(sizeof(Position)); if (!L-\u0026gt;head)exit(OVERFLOW);\t//空间分配失败 L-\u0026gt;head-\u0026gt;next = NULL; L-\u0026gt;tail = L-\u0026gt;head; L-\u0026gt;len = 0; return OK; }//构造一个空的线性链表L Status DestroyList_L(LinkList *L){ L-\u0026gt;tail = L-\u0026gt;head-\u0026gt;next; while (L-\u0026gt;tail){ L-\u0026gt;head-\u0026gt;next = L-\u0026gt;tail-\u0026gt;next; free(L-\u0026gt;tail); L-\u0026gt;tail = L-\u0026gt;head-\u0026gt;next; } free(L-\u0026gt;head); L-\u0026gt;len = 0; return OK; }//销毁L，L不在存在 Status ClearList_L(LinkList *L){ L-\u0026gt;tail = L-\u0026gt;head-\u0026gt;next; while (L-\u0026gt;tail){ L-\u0026gt;head-\u0026gt;next = L-\u0026gt;tail-\u0026gt;next; free(L-\u0026gt;tail); L-\u0026gt;tail = L-\u0026gt;head-\u0026gt;next; } L-\u0026gt;tail = L-\u0026gt;head; L-\u0026gt;len = 0; return OK; }//重置L为空表，释放原链表的结点空间 Status InsFirst_L(Link h, Link s){ s-\u0026gt;next = h-\u0026gt;next; h-\u0026gt;next = s; return OK; }//已知h指向线性表头结点，将s所指结点插入在第一个结点之前 Status DelFirst_L(Link h, Position *q){ Link p = h-\u0026gt;next; if (!p)return ERROR;\t//表空 h-\u0026gt;next = p-\u0026gt;next; *q = *p; free(p); return OK; }//已知h指向线性表头结点，删除链表中的第一个结点并以q返回 Status Append_L (LinkList *L, Link s){ L-\u0026gt;tail-\u0026gt;next = s; while (s){ L-\u0026gt;tail = s; L-\u0026gt;len++; s = s-\u0026gt;next; } return OK; }//把s所指指针接在L的最后一个结点之后，并改变链表L的尾指针指向新的尾结点 Status Remove_L(LinkList *L, Position *q){ Link p = L-\u0026gt;tail; if (L-\u0026gt;head == L-\u0026gt;tail)return ERROR;\t//表空 *q = *(L-\u0026gt;tail); L-\u0026gt;tail = L-\u0026gt;head; while (L-\u0026gt;tail-\u0026gt;next != p) L-\u0026gt;tail = L-\u0026gt;tail-\u0026gt;next; free(p); L-\u0026gt;len--; return OK; }//删除线性表L中的尾结点并以返回，改变链表L的尾指针指向新的尾结点 Status InsBefore_L(LinkList *L, Link p, Link s){ Link q = L-\u0026gt;head-\u0026gt;next; while (q-\u0026gt;next != p\u0026amp;\u0026amp;q-\u0026gt;next != NULL) q = q-\u0026gt;next; q-\u0026gt;next = s; s-\u0026gt;next = p; p = s; L-\u0026gt;len++; return OK; }//已知p指向线性表L中的一个结点，将s所指结点插入在p所指结点前 Status InsAfter_L(LinkList *L, Link p, Link s){ Link q = p-\u0026gt;next; p-\u0026gt;next = s; s-\u0026gt;next = q; if (p == L-\u0026gt;tail) L-\u0026gt;tail = s; L-\u0026gt;len++; return OK; }//已知p指向线性表L中的一个结点，将s所指结点插入在p所指结点后 Status SetCurElem_L(Link p, ElemType e){ p-\u0026gt;data = e; return OK; }//已知p指向线性表中的一个结点，用e更新p所指结点的值 ElemType GetCurElem_L(Link p){ return p-\u0026gt;data; }//已知p指向线性表中的一个结点，返回p所指结点数据元素的值 Status ListEmpty_L(LinkList L){ if (L.len == 0)return TRUE; else return FALSE; }//若线性表L为空，则放回TRUE，否则返回FALSE int ListLength_L(LinkList L){ return L.len; }//返回线性表L中的元素个数 Position* GetHead_L(LinkList L){ return L.head; }//返回L中头结点位置 Position* GetLast_L(LinkList L){ return L.tail; }//返回线性表L中最后一个结点位置 Position* PriorPos_L(LinkList L, Link p){ Link q = L.head-\u0026gt;next; while (q-\u0026gt;next != p\u0026amp;\u0026amp;q != NULL) q = q-\u0026gt;next; return q; }//已知p指向L中的一个结点，返回其前驱 Position* NextPos_L(LinkList L, Link p){ return p-\u0026gt;next; }//已知p指向线性表L中的一个结点，返回p所指结点的直接后继位置 Status LocatePos_L(LinkList L, int i, Link *p){ if (i\u0026lt;1 || i\u0026gt;L.len)return ERROR; *p = L.head; for (i; i \u0026gt;= 1; i--){ *p= (*p)-\u0026gt;next; } return OK; }//返回p指示线性表L中第i个结点的位置并返回OK，i不合法返回ERROR Position* LocateElem_L(LinkList L, ElemType e, Status(*compare)(ElemType, ElemType)){ Link p = L.head; while (p){ if ((*compare)(e, p-\u0026gt;data)) return p; p = p-\u0026gt;next; } return NULL; }//返回线性表中第一个与e满足函数compare()判定关系的元素的位置，没有返回NULL Status ListTraverse_L(LinkList L, Status(*visit)(ElemType)){ Link p = L.head; while (p){ if (!(*visit)(p-\u0026gt;data))return ERROR; p = p-\u0026gt;next; } return OK; }//依次对L的每个元素调用函数visit()。一旦失败，则操作失败 栈 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /*栈\u0026amp;结构\u0026amp;算法*/ typedef int SElemType; #define STACK_INIT_SIZE 100\t//存储空间初始分配量 #define STACKINCREMENT 10\t//存储空间分配增量 typedef struct{ SElemType *base;\t//在栈构造之前和销毁之后，base的值为NULL SElemType *top;\t//栈顶指针 int stacksize;\t//当前已分配的存储空间，以元素为单位 }SqStack; Status InitStack(SqStack *S){ S-\u0026gt;base = (SElemType*)malloc(sizeof(SElemType)*STACK_INIT_SIZE); if (!S-\u0026gt;base)exit(OVERFLOW);\t//分配失败 S-\u0026gt;top = S-\u0026gt;base; S-\u0026gt;stacksize = STACK_INIT_SIZE; return OK; }//构造一个空栈S Status DestroyStack(SqStack *S){ free(S-\u0026gt;base); S-\u0026gt;base = NULL; S-\u0026gt;top = NULL; S-\u0026gt;stacksize = 0; return OK; }//销毁栈S，S不再存在 Status ClearStack(SqStack *S){ S-\u0026gt;top = S-\u0026gt;base; return OK; }//把栈S置空 Status StackEmpty(SqStack S){ if (S.base == S.top)return TRUE; else return FALSE; }//栈为空返回TRUE，否则返回FALSE int StackLength(SqStack S){ int SElem_num = 0; SElem_num = S.top - S.base; return SElem_num; }//放回S的元素个数，即栈的长度 Status GetTop(SqStack S, SElemType *e){ if (StackEmpty(S))return ERROR;\t//栈空 *e = *(S.top - 1); return OK; }//若栈不空，则用e返回S的栈顶元素，并返回OK，否则返回ERROR Status Push(SqStack *S, SElemType e){ if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stacksize){ //栈满，追加空间 S-\u0026gt;base = (SElemType*)realloc(S-\u0026gt;base, sizeof(SElemType)*(S-\u0026gt;stacksize + STACKINCREMENT)); if (!S-\u0026gt;base)exit(OVERFLOW);\t//分配失败 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stacksize; S-\u0026gt;stacksize += STACKINCREMENT; } *S-\u0026gt;top ++ = e; return OK; }//插入元素e为新的栈顶元素 Status Pop(SqStack *S, SElemType *e){ if (StackEmpty(*S))return ERROR;\t//栈空 *e = * -- S-\u0026gt;top; return OK; }//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR Status StackTraverse(SqStack S, Status(*visit)(SElemType *e)){ if (StackEmpty(S))return ERROR;\t//栈空 for (int i = 0; S.base + i \u0026lt; S.top; i++) if(!(*visit)(S.base + i))return ERROR; return OK; }//从栈低依次对栈中的每个元素调用函数visit()。一旦visit()失败，则操作失败 队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 /*队列\u0026amp;结构\u0026amp;算法*/ /*单链队列，队列的链式存储结构*/ typedef int QElemType; typedef struct QNode{ QElemType data; struct QNode *next; }QNode,*QueuePtr; typedef struct{ QueuePtr front;\t//队头指针 QueuePtr rear;\t//队尾指针 }LinkQueue; Status InitQueue(LinkQueue *Q){ Q-\u0026gt;front = (QueuePtr)malloc(sizeof(QNode)); if (!Q-\u0026gt;front)exit(OVERFLOW);\t//空间分配失败 Q-\u0026gt;rear = Q-\u0026gt;front; return OK; }//构造一个空队列 Status DestroyQueue(LinkQueue *Q){ while (Q-\u0026gt;front){ Q-\u0026gt;rear = Q-\u0026gt;front-\u0026gt;next; free(Q-\u0026gt;front); Q-\u0026gt;front = Q-\u0026gt;rear; } return OK; }//销毁队列Q，Q不在存在 Status ClearQueue(LinkQueue *Q){ QueuePtr p = Q-\u0026gt;front; while (p){ Q-\u0026gt;rear = p-\u0026gt;next; free(p);\t//逐个释放空间 p = Q-\u0026gt;rear; } Q-\u0026gt;rear = Q-\u0026gt;front;\t//置空 return OK; }//将Q清为空队列 Status QueueEmpty(LinkQueue Q){ if (Q.rear == Q.front)return TRUE; else return FALSE; }//若队列Q为空队列，则返回TRUE，否则返回FALSE int QueueLength(LinkQueue Q){ int QueueL = 0; QueueL = Q.rear - Q.front; return QueueL; }//返回Q的元素个数，即为队列的长度 Status GetHead(LinkQueue Q, QElemType *e){ if (QueueEmpty(Q)) return ERROR;\t//队空 *e = Q.front-\u0026gt;next-\u0026gt;data; return OK; }//若e不空，用e返回Q队头元素，并返回OK，否则返回ERROR Status DeQueue(LinkQueue *Q, QElemType *e){ QueuePtr p = NULL; if (QueueEmpty(*Q))return ERROR; p = Q-\u0026gt;front-\u0026gt;next; Q-\u0026gt;front-\u0026gt;next = p-\u0026gt;next; *e = p-\u0026gt;data; if (Q-\u0026gt;rear == p)Q-\u0026gt;rear = Q-\u0026gt;front; free(p); return OK; }//若e不空，则删除Q的队头元素，用e返回其值，并返回OK，否则ERROR Status QueueTraverse(LinkQueue Q, Status visit(QElemType*)){ QueuePtr p; if (QueueEmpty(Q))return ERROR; p = Q.front-\u0026gt;next; for (int i = QueueLength(Q); i \u0026gt; 0; i--){ if (!visit(\u0026amp;(p-\u0026gt;data)))return ERROR; p = p-\u0026gt;next; } return OK; }//从队头到队尾，依次对Q的每个元素调用函数visit()，失败则返回ERROR 结尾 参考：数据结构（C语言版）第五版-严蔚敏\n","date":"2018-10-26T23:46:25+08:00","permalink":"https://c-poet.github.io/post/coding/c/data-structure-basic-algorithms/","title":"数据结构基本算法录入"},{"content":"前言 在编写程序的时候，大多数需要对文件进行操作。虽然C语言函数库提供了一些对文件操作的函数，但是对于一些新手来说。如何读取文件是一个大的问题，如果只是简单的从文件中读取一个字符，可以使用getc函数读取。可是在读取一段或者整个文件的内容时，很多人都不知道如何下手，下面就简单的说说如何使用C语言读取整个文件的内容。\n（对C基本掌握的人都知道fgets函数可以从文件中读取n个字节的数据，但是fgets存在一个弊端，那就是当读取遇见换行符时就会截至，这可能会导致我们不能获得想要的数据。如果有很多的数据的话，使用fgets读取出来不便于我们查找和操作。所以数据文件我们更多的是使用二进制存储。然后使用fread进行读取操作，这样读取的数据具有一定的格式和结构方便于我们的操作。如果想知道更多更详细的文件操作方法，可以关注博客或者想博主提问）。\n实现 注意：引入的头文件为stdio.h\n写测试文件 1 2 3 4 5 6 7 8 9 //写入文件 void file_w(int n) { int i=0,p[100]; FILE *data; for (i; i\u0026lt;n; i++,p[i]=i+2); data=fopen(\u0026#34;test.orb\u0026#34;,\u0026#34;wb\u0026#34;); fwrite(p,sizeof(int),n,data); fclose(data); } 简单获取文件的字节数 1 2 3 4 5 6 7 8 9 //返回文件的字节数 int int_num() { int t; FILE *data=fopen(\u0026#34;test.orb\u0026#34;,\u0026#34;rb\u0026#34;); fseek(data,0L,2); t=ftell(data); fclose(data); return t; } 主函数 1 2 3 4 5 6 7 8 int main() { int n; printf(\u0026#34;测试数量：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); file_w(n); printf(\u0026#34;int的数目：%d,字节数：%d\\n\u0026#34;,int_num()/sizeof(int),int_num); return 0; } 效果图 在获取文件的字节大小后，我们可以除以变量类型的字节数，然后通过calloc开辟同样大小的空间载入数据，在通过fread进行读取。这样就可以把整个文件的数据读取出来。\n","date":"2018-08-09T23:39:08+08:00","permalink":"https://c-poet.github.io/post/coding/c/c-read-file-content/","title":"C语言读取文件大小，载入文件全部内容"},{"content":"前言 利用C语言简单写的一个通讯录实例，因为要交的原因，所以在编写的时候也是寥寥收场。主要实现的就是添加、删除、修改联系人，然后把数据写入存储文件。编写环境VS2013，测试环境DEVC++。在VC++中是不能编译的，VC会报错的原因是在编写的时候在循环中添加局部变量，正好VC不支持这样的局部变量，如果有需要的同学可以把变量的声明提到函数主体前，这样VC是可以正常编译的。\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 代码： /* **通讯录 **ASorb time:201807 */ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #define max_list 99\t//联系人最高条目 #define max_notes 45\t//记事本条目 #define data_file \u0026#34;addresslist.dat\u0026#34;\t//数据文件 #define notes_file \u0026#34;notes_data.txt\u0026#34;\t//记事本数据 #define address_n address_num()\t//统计函数 //定义全局结构体变量 typedef struct address{ char name[20]; char phone[12]; char birthday[9]; }address; //定义记事本结构体 typedef struct notes{ char title[40]; char content[200]; }notes; //欢迎页面 void welcome(){ system(\u0026#34;color 4F\u0026#34;); printf(\u0026#34;欢迎使用通讯录！\\n\\n\\n\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t╭────────────────────────────────────────────╮\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t│名称：通讯录实例 ┃\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t│数信学院 计科2班 王/// 201742010// ┃\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t╰━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╯\\n\u0026#34;); printf(\u0026#34;\\n\\n回车键进入......\u0026#34;); fflush(stdin);\t//强制清除缓存流 getchar(); } //主界面 char interphase(){ int address_num();\t//声明统计函数 char home; system(\u0026#34;color 9F\u0026#34;); printf(\u0026#34;通讯录（数据文件：%s）\\t容量：%d条\\t已用：%d条\\n\\n\\n\u0026#34;,data_file, max_list, address_n); printf(\u0026#34;\\t\\t\\tA.查看联系人\\t\\tB.修改联系人\\n\\n\u0026#34;); printf(\u0026#34;\\t\\t\\tC.删除联系人\\t\\tD.新建联系人\\n\\n\u0026#34;); printf(\u0026#34;\\t\\t\\tQ.退出通讯录\\n\\n\\t\\t附加功能：\\n\\t\\t\\tT.备忘录\\n\\n\\n\u0026#34;); printf(\u0026#34;--------------\\n键入序号：\u0026#34;); fflush(stdin); home = getchar(); if ((home\u0026lt;\u0026#39;A\u0026#39; || home\u0026gt;\u0026#39;D\u0026#39;) \u0026amp;\u0026amp; home != \u0026#39;Q\u0026#39;\u0026amp;\u0026amp;home != \u0026#39;T\u0026#39;) { system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：选择有误，重新选择！\\n\u0026#34;); interphase(); } else return home; } //检查文件 void file_true(){ address arr[2] = { { \u0026#34;test1\u0026#34;, \u0026#34;18212296321\u0026#34;, \u0026#34;19980202\u0026#34; }, { \u0026#34;test2\u0026#34;, \u0026#34;18212296320\u0026#34;, \u0026#34;19980302\u0026#34; }};\t//定义两条测试数据 FILE *data = fopen(data_file, \u0026#34;rb\u0026#34;); if (data == NULL){ data = fopen(data_file, \u0026#34;wb\u0026#34;); fwrite(arr, sizeof(address),2, data);\t//写入测试数据 } fclose(data);\t//关闭文件 } //读取文件 void file_read(address *p){ FILE *data = fopen(data_file, \u0026#34;rb\u0026#34;); fread(p, sizeof(address), max_list, data); fclose(data); } //写入文件 void file_write(address *p){ int count = 0; while (((p + count)-\u0026gt;name[0]) != NULL){ count++; } FILE *data = fopen(data_file, \u0026#34;wb\u0026#34;); fwrite(p, sizeof(address), count, data); fclose(data); } //查看联系人 void address_list(){ int address_num(); address list[max_list] = {0}; static int num = 0; char h_1; file_read(list); printf(\u0026#34;查看联系人:\\n\\n\\n\u0026#34;); int i = 0; printf(\u0026#34;\\t\\t\\t┌────────────────────┬─────────────┬──────────┐\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t│ 姓 名 │ 手 机 号 码 │ 出生日期│\\n\u0026#34;); for (int i = 0; (i \u0026lt; max_list) \u0026amp;\u0026amp; (list[i].name[0] != NULL); i++){ printf(\u0026#34;\\t\\t\\t├────────────────────┼─────────────┼──────────┤\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t│%-20s│%13s│%10s│\\n\u0026#34;, list[i].name, list[i].phone, list[i].birthday); } printf(\u0026#34;\\t\\t\\t└────────────────────┴─────────────┴──────────┘\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t$$$共有%d位联系人\\n\u0026#34;, address_num()); printf(\u0026#34;\\n\\n-----------\\nR.刷新联系人\\t其它键返回主菜单\\n\u0026#34;); fflush(stdin); h_1 = getchar(); if (h_1 == \u0026#39;R\u0026#39;){ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;第%d次刷新！\u0026#34;, ++num); address_list(); } } //修改联系人 void address_edit(){ address user; address list[max_list] = { 0 }; char h_1 = NULL; file_read(list); printf(\u0026#34;\\n-------------\\n输入姓名：\u0026#34;); fflush(stdin); gets(user.name); for (int i = 0; (i \u0026lt; max_list) \u0026amp;\u0026amp; list[i].name[0] != NULL; i++){ if (strcmp(list[i].name, user.name) == 0){ printf(\u0026#34;输入新名字（为空不做修改）：\u0026#34;); fflush(stdin); gets(user.name); printf(\u0026#34;输入新号码（为空不做修改）：\u0026#34;); fflush(stdin); gets(user.phone); printf(\u0026#34;输入出生日期（为空不做修改）：\u0026#34;); fflush(stdin); gets(user.birthday); if (strlen(user.name) \u0026gt; 0){ strcpy(list[i].name, user.name); h_1 = \u0026#39;Y\u0026#39;; } if (strlen(user.phone) \u0026gt; 0){ strcpy(list[i].phone, user.phone); h_1 = \u0026#39;Y\u0026#39;; } if (strlen(user.birthday) \u0026gt; 0){ strcpy(list[i].birthday, user.birthday); h_1 = \u0026#39;Y\u0026#39;; } break; } } if (h_1 == \u0026#39;Y\u0026#39;){ file_write(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;联系人修改成功！\u0026#34;); address_list(); } else{ printf(\u0026#34;修改失败,任意键返回!\\n\u0026#34;); fflush(stdin); getchar(); } } //删除联系人 void address_del(){ int address_num(); address user; address list[max_list] = { NULL }; char h_1 = NULL; file_read(list); printf(\u0026#34;\\n-----------------\\n输入姓名：\u0026#34;); fflush(stdin); gets(user.name); for (int i = 0; (i \u0026lt; max_list) \u0026amp;\u0026amp; list[i].name[0] != NULL; i++){ if (strcmp(list[i].name, user.name) == 0) { for (i; (i \u0026lt; max_list - 1) \u0026amp;\u0026amp; list[i + 1].name[0] != NULL; i++){ list[i] = list[i + 1]; } list[i].name[0] = NULL; h_1 = \u0026#39;Y\u0026#39;; break; } } if (h_1 == \u0026#39;Y\u0026#39;){ file_write(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;联系人删除成功！\u0026#34;); address_list(); } else{ printf(\u0026#34;删除失败,任意键返回!\\n\u0026#34;); fflush(stdin); getchar(); } } //新建联系人 void address_new(){ int address_num(); int address_num_1 = address_num(); address user; address list[max_list] = { NULL }; char h_1 = NULL; printf(\u0026#34;\\n----------------\\n输入姓名（20字符内）：\u0026#34;); fflush(stdin); gets(user.name); printf(\u0026#34;输入手机号码（11位）：\u0026#34;); fflush(stdin); gets(user.phone); printf(\u0026#34;输入出生日期（如：19980202）：\u0026#34;); fflush(stdin); gets(user.birthday); if (strlen(user.name) \u0026lt;= 0 || strlen(user.name) \u0026gt; 20) printf(\u0026#34;错误1：姓名不符合规定！\u0026#34;); else if (strlen(user.phone) != 11) printf(\u0026#34;错误2：手机号不正确！\u0026#34;); else if (strlen(user.birthday) != 8) printf(\u0026#34;错误3：出生日期格式错误！\u0026#34;); else{ file_read(list); //重排联系人 for (int i = 0; i \u0026lt; address_num_1; i++){ if (strcmp(user.name, list[i].name)\u0026lt;0){ for (int ii = address_num_1; ii \u0026gt; i; ii--) list[ii] = list[ii - 1]; list[i] = user; h_1 = \u0026#39;Y\u0026#39;; break; } else if (i == address_num_1 - 1){ list[address_num_1] = user; h_1 = \u0026#39;Y\u0026#39;; } } } if (h_1 == \u0026#39;Y\u0026#39;){ file_write(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;新建联系人成功！\u0026#34;); address_list(); } else{ printf(\u0026#34;新建失败,任意键返回!\\n\u0026#34;); fflush(stdin); getchar(); } } //统计条目 int address_num(){ int num = 0; address list[max_list] = { NULL }; file_read(list); for (num; (num \u0026lt; max_list) \u0026amp;\u0026amp; list[num].name[0] != NULL; num++); return num; } //附加记事本功能\u0026amp;界面 void notes_interphase(){ int notes_num(); void add_notes(); void view_notes(); char h_1; while (1){ printf(\u0026#34;记事本(数据文件%s)\\t容量：%d\\t已用：%d\\n\u0026#34;,notes_file, max_notes, notes_num()); printf(\u0026#34;\\n\\n\\t\\t\\tA.记事\\t\\tB.查看\\n\\n\\t\\t\\tQ.返回上一级\\n\\n\u0026#34;); printf(\u0026#34;\\n----------------\\n键入序号：\u0026#34;); fflush(stdin); h_1 = getchar(); if (h_1 == \u0026#39;A\u0026#39;) add_notes(); else if (h_1 == \u0026#39;B\u0026#39;) view_notes(); else if (h_1 == \u0026#39;Q\u0026#39;) break; else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：选择有误，重新选择！\\n\u0026#34;); notes_interphase(); } } } //记事文件读取 void notes_read(notes *p){ FILE *data = fopen(notes_file,\u0026#34;rb\u0026#34;); if (data == NULL)\t//文件不存在 data = fopen(notes_file, \u0026#34;wb+\u0026#34;); fread(p, sizeof(notes), max_notes, data); fclose(data); } //记事本文件存储 void notes_save(notes *p){ int count = 0; FILE *data = fopen(notes_file, \u0026#34;wb\u0026#34;); while ((p + count)-\u0026gt;title[0] != NULL) count++; fwrite(p, sizeof(notes), count, data); fclose(data); } //记事 void add_notes(){ int notes_num(); notes new_notes; notes list[max_notes] = { NULL }; printf(\u0026#34;\\n--------------\\n题目：\u0026#34;); fflush(stdin); gets(new_notes.title); printf(\u0026#34;正文：\u0026#34;); fflush(stdin); gets(new_notes.content); if ((strlen(new_notes.title) \u0026gt; 0) \u0026amp;\u0026amp; (strlen(new_notes.content) \u0026gt; 0)){ notes_read(list); list[notes_num()] = new_notes; notes_save(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：保存成功！\\n\u0026#34;); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：内容有误，保存失败！\\n\u0026#34;); } } //查看记事本 void view_notes(){ int notes_num(),i,link; char view, h_1 = NULL; notes list[max_notes] = { NULL }; notes_read(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;查看记事本\\n\\n\u0026#34;); printf(\u0026#34;\\t\\t\\t\\t%5s\\t%-40s\u0026#34;, \u0026#34;序号\u0026#34;, \u0026#34;题目\\n\u0026#34;); for (int i = notes_num(), ii = 0; i \u0026gt; 0; i--, ii++) printf(\u0026#34;%d \\t% -40s\\n\u0026#34;, ii, list[ii].title); printf(\u0026#34;\\n总数目：%d\\tD.删除\\tR.阅读\\n\u0026#34;,notes_num()); printf(\u0026#34;\\n--------------\\n键入操作：\u0026#34;); fflush(stdin); view = getchar(); printf(\u0026#34;输入序号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;link); if (view == \u0026#39;D\u0026#39;){ if (link \u0026gt;= 0 \u0026amp;\u0026amp; link \u0026lt; notes_num()){ for (i = link; (i \u0026lt; max_list - 1) \u0026amp;\u0026amp; list[i + 1].title[0] != NULL; i++){ list[i] = list[i + 1]; } list[i].title[0] = NULL; h_1 = \u0026#39;Y\u0026#39;; } if (h_1 == \u0026#39;Y\u0026#39;){ notes_save(list); system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：删除成功！\\n\u0026#34;); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：操作有误，返回上级！\\n\u0026#34;); } } else if (view == \u0026#39;R\u0026#39;){ printf(\u0026#34;------------\\n正在阅读《%s》\\n\u0026#34;, list[link].title); printf(\u0026#34;正文：%s\u0026#34;, list[link].content); printf(\u0026#34;\\n\\n$$2018 任意键返回！\u0026#34;); fflush(stdin); getchar(); system(\u0026#34;cls\u0026#34;); } else{ system(\u0026#34;cls\u0026#34;); printf(\u0026#34;提示：操作有误，返回上级！\\n\u0026#34;); } } //记事本统计函数 int notes_num(){ int num = 0; notes list[max_notes] = { NULL }; notes_read(list); for (num; (num \u0026lt; max_notes) \u0026amp;\u0026amp; list[num].title[0] != NULL; num++); return num; } int main(){ system(\u0026#34;mode con cols=93 lines=28\u0026#34;);\t//初始化窗口大小 file_true(); char h_1; welcome(); while (1){ system(\u0026#34;cls\u0026#34;); h_1 = interphase(); if (h_1 == \u0026#39;Q\u0026#39;) break; else{ switch (h_1){ case \u0026#39;A\u0026#39;: system(\u0026#34;cls\u0026#34;); address_list(); break; case \u0026#39;B\u0026#39;: address_edit(); break; case \u0026#39;C\u0026#39;: address_del(); break; case \u0026#39;D\u0026#39;: address_new(); break; case \u0026#39;T\u0026#39;: system(\u0026#34;cls\u0026#34;); notes_interphase(); break; } } } return 0; } 效果 下面提供一些效果图：\n下载 DEVC++运行源代码下载：https://download.csdn.net/download/qq_42304721/10592956\n","date":"2018-08-09T23:30:31+08:00","image":"https://c-poet.github.io/post/coding/c/c-address-book/20180809120111917_hud2713289ccbef0d7caa992f6133e1b8e_34033_120x120_fill_box_smart1_3.png","permalink":"https://c-poet.github.io/post/coding/c/c-address-book/","title":"C语言通讯录实例"}]